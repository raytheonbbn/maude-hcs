--- MAUDE_HCS: maude_hcs
---
--- Software Markings (UNCLASS)
--- Maude-HCS Software
---
--- Copyright (C) 2025 RTX BBN Technologies Inc. All Rights Reserved
---
--- The computer software and computer software documentation are licensed
--- under the Apache License, Version 2.0 (the "License"); you may not use
--- this file except in compliance with the License. A copy of the License
--- is provided in the LICENSE file, but you may obtain a copy of the
--- License at:  https://www.apache.org/licenses/LICENSE-2.0
---
--- The computer software and computer software documentation are based
--- upon work supported by the Defense Advanced Research Projects Agency (DARPA)
--- under Agreement No. HR00l 12590083.
---
--- This document does not contain technology or technical data controlled under
--- either the U.S. International Traffic in Arms Regulations or the U.S. Export
--- Administration Regulations.
---
--- DISTRIBUTION STATEMENT A: Approved for public release; distribution is
--- unlimited.
---
--- Notice: Markings. Any reproduction of this computer software, computer
--- software documentation, or portions thereof must also reproduce the markings
--- contained herein. Refer to the provided NOTICE file.
---
--- MAUDE_HCS: end

set show advisories off .

sload ../common/maude/byteseq.maude
sload ../../deps/dns_formalization/Maude/common/actor.maude

sload ../../deps/dns_formalization/Maude/dns/probabilistic-model/parameters.maude

sload ../common/maude/_aux.maude  ---- AttributeSetMsgs
sload ../common/maude/cp2-interfaces

***** functions used by Content Manager
fmod EFRAGMENTS is
  inc BYTESEQ .

vars bytes bytes0 efrag ef efile : ByteSeq .
vars efl efl1 efl0 : ByteSeqL .
vars id n j k l l0 cap tot tot0 oh ix ix0  : Nat .
vars fragMx last accum : Nat .


---- accumulate efragments in sorted list
---- if efl is sorted by increasing ix
---- then addEfrags(efl0,efl) is sorted
op addEfrags : ByteSeqL ByteSeqL -> ByteSeqL .
op addEfrag : ByteSeq ByteSeqL ByteSeqL -> ByteSeqL .

eq addEfrags(nilBS,efl) = efl . 
eq addEfrags(ef :: efl0, efl) =
      addEfrags(efl0, addEfrag(ef,efl,nilBS)) .

eq addEfrag(ef,nilBS,efl) =  efl :: ef .
eq addEfrag(efrag(bytes,tot,ix,l),
            efrag(bytes,tot0,ix0,l0) :: efl0,efl)  = 
 (if ix < ix0
 then  efl :: efrag(bytes,tot,ix,l) ::
       efrag(bytes,tot0,ix0,l0) :: efl0
 else (if ix == ix0   ---- drop duplicates
       then efl :: efrag(bytes,tot0,ix0,l0) :: efl0
       else addEfrag(efrag(bytes,tot,ix,l), efl0, 
               efl :: efrag(bytes,tot0,ix0,l0) ) 
     fi) fi)
.

**** What if frags mixed from different files?
eq addEfrag(efrag(bytes,tot,ix,l),
          efrag(bytes0,tot0,ix0,l0) :: efl0,
          efl)  = 
         efl :: efrag(bytes0,tot0,ix0,l0) :: efl0 
 [owise print "Bad frag dropped " bytes " expected " bytes0]
  .


---- efl is sorted by ix,  should have 0 1 ... last
op efraglComplete? : ByteSeqL -> ByteSeqL . --- nil or efile
op efraglComplete?X : ByteSeqL Nat -> Bool .
op hasLastFrag : ByteSeqL -> ByteSeqL .

eq efraglComplete?(efl) = 
   (if efraglComplete?X(efl,0) 
    then hasLastFrag(efl) 
    else nilBS
    fi) .
   
eq efraglComplete?X(efrag(efile,tot,ix,l) :: efl, ix)
     =  efraglComplete?X(efl, s ix) .
eq  efraglComplete?X(nilBS, ix) = true .
eq  efraglComplete?X(efl,ix) = false [owise] .

eq hasLastFrag(efl :: efrag(efile,tot,ix,l)) 
   =
   (if tot >= nbytes(efile) 
    then efile
    else nilBS
    fi )
   .   
   
eq hasLastFrag(efl) = nilBS [owise] .

endfm


---- {attrs,conf} defined in lib/.../common/_aux.maude
mod CONTENT-MANAGER is
  inc BYTESEQ .
  inc EFRAGMENTS .
  inc RB-INTERFACE .
  inc MC-INTERFACE .
  inc ACTOR-MODEL .
  pr PARAMETERS .
--- inc PARAMETERS-COMMON + SAMPLER + APMAUDE .
  pr CP2_SORTS .  --- for AttributeSetMsgs  
    ---- need to pull it out to share file -- like actors
  
vars attrs : AttributeSet .
vars msg msg0 : Msg .
vars msgs msgs0 config config0 : Config .
vars j l : Nat .
vars bAddr : Address .
vars efl0 efl : ByteSeqL .
vars addr : Address .
vars atype : ActorType .

  
ops CMClient CMServer  : -> ActorType .

**** Attributes
op bHashTagCtr:_ :  Nat -> Attribute [ctor] . 
    ---- for background traffic
op textCtr:_ :  Nat -> Attribute [ctor] .
op textSize:_ : Nat -> Attribute [ctor] .
op pendingFiles:_ : ByteSeqL -> Attribute [ctor] .
op currentFrags:_   : ByteSeqL -> Attribute [ctor] .
op pendingHashTags:_ : ByteSeqL -> Attribute [ctor] .
op numBHashTags:_ : Nat -> Attribute [ctor] .

op edAddress:_  : Address -> Attribute [ctor] .
op mcAddress:_ : Address -> Attribute [ctor] .
op bobAddress:_  : Address -> Attribute [ctor] .
op w4c:_ : Config -> Attribute [ctor] . ---msg or null
op replyTo:_ : Config -> Attribute [ctor] . ---- ""


op setReplyTo : Actor Msg -> Actor .
eq setReplyTo( < addr : atype | attrs > , msg) =
     < addr : atype | setReplyTo(attrs, msg) > .
op setReplyTo : AttributeSet Msg -> AttributeSet .
eq setReplyTo((attrs, replyTo: msgs), msg)
     = attrs, replyTo: msg .
eq setReplyTo(attrs, msg) = attrs [owise] .


op setW4c : Actor Msg -> Actor .
eq setW4c( < addr : atype | attrs > , msg) =
     < addr : atype | setW4c(attrs, msg) > .
op setW4c : AttributeSet Msg -> AttributeSet .
eq setW4c((attrs, w4c: msgs), msg)
     = attrs, w4c: msg .
eq setW4c(attrs, msg) = attrs [owise] .

op setPendingFiles : Actor ByteSeqL -> Actor .
eq setPendingFiles( < addr : atype | attrs > , efl) =
     < addr : atype | setPendingFiles(attrs, efl) > .
op setPendingFiles : AttributeSet ByteSeqL 
                      -> AttributeSet .
eq setPendingFiles((attrs,pendingFiles: efl0),efl)  
    = attrs, pendingFiles: efl .                   
eq setPendingFiles(attrs,efl)  = attrs [owise] .

op setCurrentFrags : Actor ByteSeqL -> Actor .
eq setCurrentFrags( < addr : atype | attrs > , efl) =
     < addr : atype | setCurrentFrags(attrs, efl) > .
op setCurrentFrags : AttributeSet ByteSeqL 
                      -> AttributeSet .
eq setCurrentFrags((attrs,currentFrags: efl0),efl)  
    = attrs, currentFrags: efl .                   
eq setCurrentFrags(attrs,efl)  = attrs [owise] .
                      
--- op delayMsgs : Config Config -> Config .
--- eq delayMsgs(null,config) = config .
--- eq delayMsgs(msg msgs0, config) =
---    delayMsgs(msgs0, config [delayParamd(msg),msg,0] )
---   .
  
***(
op incWHashTagCtr : AttributeSet -> AttributeSet .
eq incWHashTagCtr((attrs, wHashTagCtr: j)) =
     attrs,  wHashTagCtr: (s j) . 
)
op incBHashTagCtr : AttributeSet -> AttributeSet .
eq incBHashTagCtr((attrs, bHashTagCtr: j,
                   numBHashTags: l)) 
   = attrs, numBHashTags: l,
     bHashTagCtr:  (if j >= l then 0 else s j fi) . 

op getBobAddress : AttributeSet -> Address .
eq getBobAddress((attrs, bobAddress: bAddr)) = bAddr .

endm


eof


