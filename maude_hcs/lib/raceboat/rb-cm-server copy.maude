load ../common/maude/markov-action-model.maude
load ../common/maude/cp2-interfaces 
load cm-aux.maude

***(
req/rsp for CMServer

UM -actionQ(downloadAct)-> CMC 
    (replyTo: ummsg)
            [ht := curHashtag]  --- pend if any, ow bHash
            CMC -fetchQ(ht)-> MC
    (w4c: mcmsg)
            CMC <fetchR(images) - MC
            [process fetch results ]
    (if file complete
     then [Bob <file,ht- CMS]
     else null fi)
    (w4c: null)            
UM <actionR("ok")- CMC   
    (replyTo: null)

-----------------
[post image same as Client case no files, no frags]
)

mod CONTENT-MANAGER-SERVER is
  inc CONTENT-MANAGER .
  inc MARKOV-ACTION-MODEL .
  inc CP2-COMMON .
  inc MC-INTERFACE  .
  inc ED-INTERFACE .
  inc TGEN-INTERFACE .


vars attrs attrs0 attrs1 attrs2 : AttributeSet .
vars cmsAtts cmsAtts1 cmsAtts2 : AttributeSet .
vars msg msg0 msg1 : Msg .
vars msgs msgs0 config config0 : Config .
vars j j1 i k l n cap : Nat .
vars bAddr cmsAddr umAddr edAddr mcAddr : Address .
vars T : Float .
vars mcResponse : Content .
vars efile efrag image ht hashtag bytes : ByteSeq .
vars efilel efragl efragl0 efragl1 efragl3 imagel hashtagl : ByteSeqL .
vars str : String .
vars ract : Map{String,JV} .

op mkCMSAttrs : Address Address Address Nat
                 -> AttributeSet .
eq mkCMSAttrs(edAddr,mcAddr,bAddr,l) =
   bHashTagCtr: 0,
   numBHashTags: l,
   pendingHashTags: nilBS,
   pendingFiles: nilBS,
   currentFrags: nilBS,
   edAddress:  edAddr,
   mcAddress: mcAddr,
   w4c: null,
   replyTo: null, 
   bobAddress: bAddr
 .

op mkCMServer : Address Address Address Address Nat
                 -> Actor .
eq mkCMServer(cmsAddr,edAddr,mcAddr,bAddr,l) =
  < cmsAddr : CMServer | 
    mkCMSAttrs(edAddr,mcAddr,bAddr,l)  >
 .

--- rbs receives hashtag from bob
--- models bob writing shared file
rl [rbc-rcv-hashtag] :
{T, (to cmsAddr from bAddr :  pkg(hashtag) )}
< cmsAddr : CMServer | cmsAtts, 
                       pendingHashTags: hashtagl >
=>
< cmsAddr : CMServer | cmsAtts, 
                      pendingHashTags: (hashtagl :: hashtag) >
[print "(" T "): rbs-rcv-hashtag raceboat server received hashtag #"  hashtag " from Bob, add to pending." ]
.

crl [rbs-rcv-actionQ] :
{T,(to cmsAddr from umAddr :  actionQ(ract) )}
< cmsAddr : CMServer | cmsAtts >
=>
< cmsAddr : CMServer | cmsAtts1 >
delayMsgs(msgs,null)
if {cmsAtts1,msgs} := 
  srcvActionQ(cmsAtts,getType(ract),
              (to cmsAddr from umAddr : actionQ(ract))) 
[print "(" T "): rbs-rcv-actionQ raceboat server received action request " ract ", sending " msgs]
 .

op srcvActionQ : AttributeSet String Msg
                   -> AttributeSetMsgs . 
**** eq srcvActionQ(attrs,str,msg) = {attrs,null} [owise] .
ceq srcvActionQ(attrs,str,msg) = {attrs,msg}
if (to cmsAddr from umAddr : actionQ(ract)) := msg
/\ msg := (to umAddr from cmsAddr : actionR("notRecognized"))
 [owise] .
**** Do we need to check replyTo null to reply failure?

---- download case fetch using first pending hashTag if any
---- ow fetch bHashTag
ceq srcvActionQ(attrs, "download", msg0) = {attrs2,msg}
if (to cmsAddr from umAddr : actionQ(ract) ) := msg0
/\ attrs0, replyTo: null, w4c: null := attrs
/\ attrs1, mcAddress: mcAddr, 
           pendingHashTags: (hashtag :: hashtagl)
           := attrs
/\ msg := (to mcAddr from cmsAddr : fetchQ(hashtag))
/\ attrs2 := attrs0, replyTo: msg0, w4c: msg
.

---- ow fetch using bHashTag
ceq srcvActionQ(attrs, "download", msg0) = {attrs2,msg}
if (to cmsAddr from umAddr : actionQ(ract) ) := msg0
/\ attrs0, replyTo: null, w4c: null, bHashTagCtr: j
           := attrs
/\ attrs1, mcAddress: mcAddr, numBHashTags: l,
           pendingHashTags: nilBS := attrs
/\ ht := bHashTag(j)           
/\ j1 := (if j >= l then 0 else s j fi)
/\ msg := (to mcAddr from cmsAddr : fetchQ(ht))
/\ attrs2 := attrs0, replyTo: msg0, w4c: msg,
                     bHashTagCtr: j1
.


---- rcv fetch response from mcAddr
crl [rbs-rcv-fetchR] :
{T,(to cmsAddr from mcAddr :  fetchR(imagel,ht))}
< cmsAddr : CMServer | cmsAtts >
=>
< cmsAddr : CMServer | cmsAtts1 >
delayMsgs(msgs,null)
if {cmsAtts1,msgs} := srcvFetchR(cmsAtts,
             (to cmsAddr from mcAddr : fetchR(ht,imagel)))   
[print "(" T "): rbs-rcv-fetchR raceboat server got fetch response " imagel " for tag " ht ", sending " msgs ]
.

 ---- rcv fetchR , ask ed to decode imagel
op srcvFetchR : AttributeSet Msg -> AttributeSetMsgs .
eq srcvFetchR(attrs,msg) = {attrs,null} [owise] .

---- bHashtag download
ceq srcvFetchR(attrs,
             (to cmsAddr from mcAddr : fetchR(ht,imagel)) )
    = {attrs1,msg}
if attrs0, w4c: (to mcAddr from cmsAddr : fetchQ(ht)),
           replyTo: (to cmsAddr from umAddr : actionQ(ract))
            := attrs
/\ bHashTag(j) := ht
/\ msg := (to umAddr from cmsAddr : actionR("ok"))    
/\ attrs1 := attrs0,  w4c: null, replyTo: null
.    

---- wHashtag download no images
ceq srcvFetchR(attrs,(to cmsAddr from mcAddr :
                       fetchR(ht,nilBS)) )  
         = {attrs2,msg}
if attrs0, w4c: (to mcAddr from cmsAddr : fetchQ(ht)),
    replyTo: (to cmsAddr from umAddr : actionQ(ract))
           := attrs
/\ attrs1, pendingHashTags: (ht :: hashtagl) := attrs
/\ msg := (to umAddr from cmsAddr : actionR("ok"))
/\ attrs2 := attrs0,  w4c: null, replyTo: null
.   
 
---- wHashtag download non nil result
ceq srcvFetchR(attrs,(to cmsAddr from mcAddr :
                       fetchR(ht,image :: imagel)) )  
         = {attrs2,msg}
if attrs0, w4c: (to mcAddr from cmsAddr : fetchQ(ht)) 
           := attrs
/\ attrs1, pendingHashTags: (ht :: hashtagl),
           edAddress: edAddr := attrs
/\ msg := 
    (to edAddr from cmsAddr : decQ(image :: imagel))    
/\ attrs2 := attrs0,  w4c: msg
.    



---- rcv dec response from edAddr
crl [rbs-rcv-decR] :
{T,(to cmsAddr from edAddr :  decR(efragl))}
< cmsAddr : CMServer | cmsAtts >
=>
< cmsAddr : CMServer | cmsAtts1 >
delayMsgs(msgs,null)
if {cmsAtts1,msgs} :=
    srcvDecR(cmsAtts,
             (to cmsAddr from edAddr : decR(efragl)) )   
[print "(" T "): rbs-rcv-decR raceboat server got decoded image from Destini, sending " msgs " ]
.
 
op srcvDecR : AttributeSet  Msg -> AttributeSetMsgs .
 ---- add efragl to current frags
 ----  clear w4c, clear replyTO
 ---- msg0 - status to umAddr
 ---- msg1 -- if frags complete efile to Bob ow null
 -----  if msg1 not null pop pendingHashTags
 eq srcvDecR(attrs, msg) = {attrs,null} [owise] .
 ceq srcvDecR(attrs, 
            (to cmsAddr from edAddr : decR(efragl))) 
    = {attrs2, msg0 msg1}
if attrs0, w4c: (to edAddr from cmsAddr : decQ(imagel)),
   replyTo: (to cmsAddr from umAddr : actionQ(ract)),
   currentFrags: efragl0,
   pendingHashTags: (ht :: hashtagl) := attrs    
/\ efragl1 := addEfrags(efragl,efragl0)
/\ efile := efraglComplete?(efragl1)
/\ efragl3 := (if efile == nilBS
               then efragl1 else nilBS fi)
/\ msg0 := (to umAddr from cmsAddr : actionR("ok"))
/\ msg1 := (if efile == nilBS 
            then null
            else (to getBobAddress(attrs) from cmsAddr
                    : pkg(efile,ht)) 
            fi)
/\ attrs1 := (if efile == nilBS 
              then  (currentFrags: efragl0,
                    pendingHashTags: (ht :: hashtagl) )
              else (currentFrags: nilBS,
                    pendingHashTags: hashtagl )
               fi)
/\ attrs2 := attrs0, w4c: null, replyTo: null,
             currentFrags: efragl3,
             (if efile == nilBS 
              then pendingHashTags: (ht :: hashtagl) 
              else pendingHashTags: hashtagl 
              fi)

.        

---- media request
ceq srcvActionQ(attrs, "media", msg0) = {attrs2,msg}
if (to cmsAddr from umAddr : actionQ(ract) ) := msg0
/\ attrs0, replyTo: null, w4c: null := attrs
/\ attrs1, edAddress: edAddr := attrs
/\ msg := (to edAddr from cmsAddr : encQ(noBytes))
/\ attrs2 := attrs0, replyTo: msg0, w4c: msg
.

crl [rbs-rcv-encR] :
{T,(to cmsAddr from edAddr :  encR(image) )}
< cmsAddr : CMServer | cmsAtts >
=>
< cmsAddr : CMServer | cmsAtts1 >
delayMsgs(msgs,null)
if {cmsAtts1,msgs} := srcvEncR(cmsAtts,
           (to cmsAddr from edAddr : encR(image)) )
[print "(" T "): rbs-rcv-encR raceboat server got encoded image " image " from Destini, sending " msgs ]
.

op srcvEncR : AttributeSet Msg -> AttributeSetMsgs .
eq  srcvEncR(attrs,msg) = {attrs,null} [owise] .

ceq srcvEncR(attrs,
            (to cmsAddr from edAddr : encR(image)) )
   = {attrs2,msg}
if attrs0,  bHashTagCtr: j,
          w4c:  (to edAddr from cmsAddr : encQ(bytes))
    := attrs
/\ attrs1,  mcAddress: mcAddr, numBHashTags: l := attrs 
/\ ht := bHashTag(j)   
/\ j1 := (if j >= l then 0 else s j fi) 
/\ msg := (to mcAddr from cmsAddr : tootQ(ht,image) )   
/\ attrs2 := attrs0, bHashTagCtr: j1, w4c: msg
.



 crl [rbs-rcv-tootR] :
 {T,(to cmsAddr from mcAddr :  tootR(str) )}
 < cmsAddr : CMServer | cmsAtts >
 =>
 < cmsAddr : CMServer | cmsAtts1 >
 delayMsgs(msgs,null)
 if {cmsAtts1,msgs} := srcvTootR(cmsAtts,
            (to cmsAddr from mcAddr :  tootR(str)) ) 
[print "(" T "): rbs-rcv-tootR got toot response " str " from Mastodon Client, sending " msgs ]
 .
  
  op srcvTootR : AttributeSet  Msg ->
                 AttributeSetMsgs .
 eq srcvTootR(attrs,msg) = {attrs,msg} [owise] .
 
 ceq srcvTootR(attrs,
               (to cmsAddr from mcAddr : tootR(str)) )
     = {attrs1,msg}
  if attrs0,
     w4c: (to mcAddr from cmsAddr : tootQ(ht,bytes)),
     replyTo: (to cmsAddr from umAddr : actionQ(ract))
      := attrs
  /\ msg := (to umAddr from cmsAddr : actionR("ok"))
  /\ attrs1 := attrs0, w4c: null, replyTo: null
   .
      

endm


mod CM-SERVER-TEST is
  inc CONTENT-MANAGER-SERVER .
  

ops cmsA edA mcA bA umA : -> Address .
op CMS : -> Actor .
eq CMS = mkCMServer(cmsA,edA,mcA,bA,3) .

op CMSAtts : -> AttributeSet .
eq CMSAtts = mkCMSAttrs(edA,mcA,bA,3) .

op wHT0 : -> ByteSeq .
eq wHT0 = wHashTag(0) .

op bHT0 : -> ByteSeq .
eq bHT0 = bHashTag(0) .

op F0 : -> ByteSeq .
eq F0 = file(0,20) .
op K0 : -> ByteSeq .
eq K0 = key(0,20) .

op EF0 : -> ByteSeq .
eq EF0 = encrypt(F0,K0) .

eq encOH(fsize:Nat,ksize:Nat)  = 
    (if ksize:Nat < fsize:Nat 
     then 0 
     else ksize:Nat + (- fsize:Nat) fi) .
     
op FR0 : -> ByteSeq .
eq FR0 =  efrag(EF0,20,0,20) .     
ops IM0 IM00 : -> ByteSeq .
eq IM0 = image(0,500,50)  .
eq IM00 = encode(image(0,500,50),FR0,1,4,1/10) .

ops CMSh CMSm CMSme CMSd CMShd CMShdf : -> Actor .

ops Mhash Mmedia Mdown MencR MdecR MtootR 
 MfetchRb  MfetchRw0  MfetchRw
   : -> ActiveMsg .

---- rl [rbc-rcv-hashtag] :
eq Mhash = {0.1, (to cmsA from bA :  pkg(wHT0) )} .
---- any state

---- rew CMS Mhash .
eq CMSh =
< cmsA : CMServer | bHashTagCtr: 0, pendingFiles: nilBS, currentFrags: nilBS, pendingHashTags: wHashTag(0), numBHashTags: 3, edAddress: edA, mcAddress: mcA, bobAddress: bA,
w4c: null, replyTo: null >
 .


---- crl [rbs-rcv-actionQ] :
eq Mmedia =
  {0.2,(to cmsA from umA : 
           actionQ(("type" |->  js("media")) ) )} .
---- pendingFiles: nilBS or EF0
---- (w4c: null), (replyTo: null), 
 
---- rew CMS Mmedia .
eq CMSm = 
< cmsA : CMServer | bHashTagCtr: 0, pendingFiles: nilBS, currentFrags: nilBS, pendingHashTags: nilBS, numBHashTags: 3, edAddress: edA, mcAddress: mcA, bobAddress: bA, 
w4c: (to edA from cmsA : encQ(noBytes)), 
replyTo: (to cmsA from umA : actionQ("type" |-> js("media"))) >
***  [0.0, to edA from cmsA : encQ(noBytes), 0]
.

 
eq Mdown = 
  {0.2,(to cmsA from umA : 
         actionQ(("type" |->  js("download")) ) )} .
---- (w4c: null), (replyTo: null), 


---- rew CMS Mdown .
eq CMSd =
< cmsA : CMServer | bHashTagCtr: 1, pendingFiles: nilBS, currentFrags: nilBS, pendingHashTags: nilBS, numBHashTags: 3, edAddress: edA, mcAddress: mcA, bobAddress: bA, 
w4c: (to mcA from cmsA : fetchQ(bHashTag(0))), 
replyTo: ( to cmsA from umA : actionQ("type" |-> js("download"))) >

**** [0.0, to mcA from cmsA : fetchQ(bHashTag(0)), 0]
   .
   

---- rew CMSh Mdown .
eq CMShd = 
< cmsA : CMServer | bHashTagCtr: 0, pendingFiles: nilBS, currentFrags: nilBS, pendingHashTags: wHashTag(0), numBHashTags: 3, edAddress: edA, mcAddress: mcA, bobAddress: bA, w4c: (to mcA from cmsA : fetchQ(wHashTag(0))), replyTo: (to cmsA from umA : actionQ("type" |-> js("download"))) >

**** [0.0, to mcA from cmsA : fetchQ(wHashTag(0)), 0]
.


---- rcv fetch response from mcAddr
---- crl [rbs-rcv-fetchR] :
eq MfetchRw = 
   {2.0,(to cmsA from mcA :  fetchR(nilBS,wHT0))} .
eq MfetchRb = 
  {2.0,(to cmsA from mcA :  fetchR(IM0,bHT0))} .
eq MfetchRw0 = 
    {2.0,(to cmsA from mcA : fetchR(IM00,wHT0))} .

---- rew CMSd MfetchRb .
**** < cmsA : CMServer | bHashTagCtr: 1, pendingFiles: nilBS, currentFrags: nilBS, pendingHashTags: nilBS, numBHashTags: 3, edAddress: edA, mcAddress: mcA, bobAddress: bA, w4c: null, replyTo: null >

**** [0.0, to umA from cmsA : actionR("ok"), 0]


---- rew CMShd MfetchRw .
**** < cmsA : CMServer | bHashTagCtr: 0, pendingFiles: nilBS, currentFrags: nilBS, pendingHashTags: wHashTag(0), numBHashTags: 3, edAddress: edA, mcAddress: mcA, bobAddress: bA, w4c: null, replyTo: null >

**** [0.0, to umA from cmsA : actionR("ok"), 0]

---- rew CMShd MfetchRw0 .
eq CMShdf =
< cmsA : CMServer | bHashTagCtr: 0, pendingFiles: nilBS, currentFrags: nilBS, pendingHashTags: wHashTag(0), numBHashTags: 3, edAddress: edA, mcAddress: mcA, bobAddress: bA, 
w4c: (to edA from cmsA : decQ(encode(image(0, 500, 50), efrag(efile(0, 20, 0, 20), 20, 0, 20),1,4,1/10))), 
replyTo: (to cmsA from umA : actionQ("type" |-> js("download"))) >

**** [0.0, to edA from cmsA : decQ(encode(image(0, 500, 50), efrag(efile(0, 20, 0, 20), 20, 0, 20), 1,4, 1/10)), 0]

.

---- rcv dec response from edAddr
---- crl [rbs-rcv-decR] :
eq MdecR = 
   {2.5,(to cmsA from edA :  decR(FR0))} .
--- need w4c and replyTo non null

---- rew CMShdf MdecR .
**** < cmsA : CMServer | bHashTagCtr: 0, pendingFiles: nilBS, currentFrags: nilBS, pendingHashTags: nilBS, numBHashTags: 3, edAddress: edA, mcAddress: mcA, bobAddress: bA, w4c: null, replyTo: null > 
**** [0.0, to bA from cmsA : pkg( efile(0, 20, 0, 20), wHashTag(0)), 0] 
**** [0.0, to umA from cmsA : actionR( "ok"), 0]

---- crl [rbs-rcv-encR] :
eq MencR = {2.0, (to cmsA from edA :  encR(IM00) )} .
---- need w4c and replyTo non null

---- rew CMSm MencR .
eq CMSme = 
< cmsA : CMServer | bHashTagCtr: 1, pendingFiles: nilBS, currentFrags: nilBS, pendingHashTags: nilBS, numBHashTags: 3, edAddress: edA, mcAddress: mcA, bobAddress: bA, 
w4c: (to mcA from cmsA : tootQ(bHashTag(0), encode(image( 0, 500, 50), efrag(efile(0, 20, 0, 20), 20, 0, 20), 1,4,1/10))), 
replyTo: (to cmsA from umA : actionQ("type" |-> js("media"))) >
.

**** [0.0, to mcA from cmsA : tootQ(bHashTag(0), encode(image(0, 500, 50), efrag(efile(0, 20, 0, 20), 20, 0, 20), 1, 4, 1/10)), 0] 



---- crl [rbs-rcv-tootR] :
eq MtootR =  {2.5,(to cmsA from mcA :  tootR("ok") )} .
---- need w4c and replyTo non null
 
---- rew CMSme MtootR .
**** < cmsA : CMServer | bHashTagCtr: 1, pendingFiles: nilBS, currentFrags: nilBS, pendingHashTags: nilBS, numBHashTags: 3, edAddress: edA, mcAddress: mcA, bobAddress: bA, w4c: null, replyTo: null >
**** [0.0, to umA from cmsA :  actionR("ok"), 0]


endm  

eof

Tests

CMS Mhash -> CMSh
CMS Mmedia -> CMSm MencR ->  CMSme MtootR -> .
CMS Mdown -> CMSd MfetchRb -> .
CMSh Mdown -> CMShd MfetchRw -> CMShdf ~ CMShd ~ .
              CMShd MfetchRw0 -> CMShdf MdecR ->  .
##







