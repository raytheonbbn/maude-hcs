--- MAUDE_HCS: maude_hcs
---
--- Software Markings (UNCLASS)
--- Maude-HCS Software
---
--- Copyright (C) 2025 RTX BBN Technologies Inc. All Rights Reserved
---
--- The computer software and computer software documentation are licensed
--- under the Apache License, Version 2.0 (the "License"); you may not use
--- this file except in compliance with the License. A copy of the License
--- is provided in the LICENSE file, but you may obtain a copy of the
--- License at:  https://www.apache.org/licenses/LICENSE-2.0
---
--- The computer software and computer software documentation are based
--- upon work supported by the Defense Advanced Research Projects Agency (DARPA)
--- under Agreement No. HR00l 12590083.
---
--- This document does not contain technology or technical data controlled under
--- either the U.S. International Traffic in Arms Regulations or the U.S. Export
--- Administration Regulations.
---
--- DISTRIBUTION STATEMENT A: Approved for public release; distribution is
--- unlimited.
---
--- Notice: Markings. Any reproduction of this computer software, computer
--- software documentation, or portions thereof must also reproduce the markings
--- contained herein. Refer to the provided NOTICE file.
---
--- MAUDE_HCS: end

mod SMC is

  inc HCS_TEST .
  pr LIST{Float} .

  var AC : ActorConfig .
  var attrs : AttributeSet .

  vars PTL PTL' PTL'' PTL''' : PacketTimestampList .
  vars Pkt Pkt' : Packet .
  var C : Config .
  var id : Nat .
  vars len, len' : Nat .
  var A : Actor .
  var N : Nat .
  var last? : Bool .
  vars T T' T'' T''' Tmsg : Float .
  var ADDR AppAddrFrom AppAddrTo : Address .

  var QTL QTL' : QueryTimestampList .
  var QUERY : Query .

  var TML : TimeMsgList .
  var M : Msg .
  var TH : Float .
  var GT : Float .
  var I : Int .

  var LF LF1 : List{Float} .

  var bytes : ByteSeq .

  op getMonitor : Config -> Actor .
  eq getMonitor (C < ADDR : WMonitor | attrs >) = < ADDR : WMonitor | attrs > .

  op getPktSent : Actor ->  PacketTimestampList . 
  eq getPktSent (< ADDR : WMonitor | pktSent: PTL, attrs >) = PTL . 

  op getFirstPktSentTime : Actor -> Float .
  eq getFirstPktSentTime (< ADDR : WMonitor | pktSent: (PTL ; packetTimestamp(packet(AppAddrFrom, AppAddrTo, bytes, 0, len, last?), T) ; PTL'), attrs >) = T .

  op getPktRcvd : Actor ->  PacketTimestampList . 
  eq getPktRcvd (< ADDR : WMonitor | pktRcvd: PTL, attrs >) = PTL . 

  op getLastPktRcvdTime : Actor -> Float .
  eq getLastPktRcvdTime (< ADDR : WMonitor | pktRcvd: (PTL ; packetTimestamp(packet(AppAddrFrom, AppAddrTo, bytes, id, len, true), T) ; PTL'), attrs >) = T .

  op getLatency : Actor -> Float .
  eq getLatency (< ADDR : WMonitor | pktSent: (PTL ; packetTimestamp(packet(AppAddrFrom, AppAddrTo, bytes, 0, len, last?), T) ; PTL'), pktRcvd: (PTL'' ; packetTimestamp(packet(AppAddrFrom, AppAddrTo, bytes, id, len', true), T') ; PTL'''), attrs >) = T' - T .

  op getGoodput : Actor -> Float .
  eq getGoodput (< ADDR : WMonitor | pktSent: (PTL ; packetTimestamp(packet(AppAddrFrom, AppAddrTo, bytes, 0, len, last?), T) ; PTL'), pktRcvd: (PTL'' ; packetTimestamp(packet(AppAddrFrom, AppAddrTo, bytes, id, len', true), T') ; PTL'''), attrs >) = float(8 * fileSize) / (T' - T) .

  op getPTLLen : PacketTimestampList -> Nat .
  eq getPTLLen (nilPacketTimestamp) = 0 .
  eq getPTLLen (PTL ; packetTimestamp(packet(AppAddrFrom, AppAddrTo, bytes, id, len, last?), T)) = len + getPTLLen (PTL) .

  op getThroughput : Actor -> Float .
  eq getThroughput (< ADDR : WMonitor | pktSent: (PTL ; packetTimestamp(packet(AppAddrFrom, AppAddrTo, bytes, 0, len, last?), T) ; PTL'), pktRcvd: (PTL'' ; packetTimestamp(packet(AppAddrFrom, AppAddrTo, bytes, id, len', true), T') ; PTL'''), attrs >) = float(getPTLLen((PTL'' ; packetTimestamp(packet(AppAddrFrom, AppAddrTo, bytes, id, len', true), T') ; PTL''')) * 8) / (T' - T) .

***(
  op isDone : Config -> Bool .
  eq isDone ({ F:Float | nil } AC < ADDR : WMonitor | pktRcvd: (PTL ; packetTimestamp(packet(AppAddrFrom, AppAddrTo, bytes, id, len, true), T) ; PTL'), attrs >)
    = true   
    .
  eq isDone (C) = false [owise] .

  op isDone : Config -> Bool .
  eq isDone (A { F:Float | nil } AC < ADDR : WMonitor | pktRcvd: (PTL ; packetTimestamp(packet(AppAddrFrom, AppAddrTo, bytes, id, len, true), T) ; PTL'), attrs >)
    = true   
    .
  eq isDone (C) = false [owise] .
)
  eq stopCondition (C < ADDR : WMonitor | pktRcvd: (PTL ; packetTimestamp(packet(AppAddrFrom, AppAddrTo, bytes, id, len, true), T) ; PTL'), attrs >) = true .

  op getQuerySent : Actor -> QueryTimestampList . 
  eq getQuerySent (< ADDR : WMonitor | querySent: QTL, attrs >) = QTL . 

  op length : QueryTimestampList -> Nat .
  eq length (nilQueryTimestamp) = 0 .
  eq length (QTL ; queryTimestamp(QUERY, T)) = 1 + length(QTL) .

  op length : TimeMsgList -> Nat .
  eq length (nilTML) = 0 .
  eq length (TML ; tm(T, M)) = 1 + length(TML) .

  ***(
  --- General approach for triggering adversary alarms:
  --- Time is divided into bins of width s seconds
  --- At each interval tk (every s seconds), adversary computes moving average of selected network observable over the previous m bins
  --- The initial set of m bins from t0 to tm contains TGEN-only traffic
  --- Obtained either by running scenario long enough with TGEN-only to fill initial set of m bins, or by importing m previously collected TGEN-only bins
  --- Threshold format:
  --- “Combined TGEN + HCS network observable average exceeds k * initial TGEN-only network observable average for n consecutive time intervals”
  --- “How quickly and by how much does the addition of the HCS move the TGEN-only average?”

  --- k – threshold multiplier
  --- n – number of consecutive bins
  --- s – duration of each bin/interval
  --- m – number of previous bins/intervals to compute moving average over
  )

  op lengthTimeWindow : QueryTimestampList Float Float -> Nat .
  eq lengthTimeWindow (nilQueryTimestamp, T', T'') = 0 .
  eq lengthTimeWindow (QTL ; queryTimestamp(QUERY, T), T', T'') = if T >= T' and T < T'' then 1 + lengthTimeWindow(QTL, T', T'') else lengthTimeWindow(QTL, T', T'') fi .

  ---- the number of messages that occured between T' and T''
  ----                              startT endT
  op lengthTimeWindow : TimeMsgList Float Float -> Nat .
  eq lengthTimeWindow (nilTML, T', T'') = 0 .
  eq lengthTimeWindow (TML ; tm(T, M), T', T'') = if T >= T' and T < T'' then 1 + lengthTimeWindow(TML, T', T'') else lengthTimeWindow(TML, T', T'') fi .

  op getNQuerySent : Actor -> Nat .
  eq getNQuerySent (< ADDR : WMonitor | querySent: QTL, attrs >) = length(QTL) .

  op getNQueryRcvd : Actor -> Nat .
  eq getNQueryRcvd (< ADDR : WMonitor | queryRcvd: QTL, attrs >) = length(QTL) .

  op getAdversary : Config -> Actor .
  eq getAdversary (C < ADDR : Adversary | attrs >) = < ADDR : Adversary | attrs > . 

  op getNQuerySent : Actor -> Nat .
  eq getNQuerySent (< ADDR : Adversary | sent: TML, attrs >) = length(TML) .

  ----- the avg QPS in a time window of size T' starting at T
  ---                     startT window 
  op avgQPS : TimeMsgList Float Float -> Float .
  eq avgQPS (TML, T, T') = float(lengthTimeWindow(TML, T, T + T')) / T' .

  ---- the largest timestamp in the list
  op lastT : TimeMsgList -> Float .
  eq lastT (TML ; tm(T, M)) = if T > lastT(TML) then T else lastT(TML) fi .
  eq lastT (nilTML) = 0.0 .

  ----- the QPS in window [T, T+T'] > th*(QPS in window [0, T'])
                        --- startT window threshold
  op highQPS : TimeMsgList Float Float Float -> Bool .
  eq highQPS (TML, T, T', TH) = 
      if avgQPS (TML, T,  T') > avgQPS (TML, 0.0, T') * TH 
      then true 
      else false 
      fi .
  eq highQPS (nilTML, T, T', TH) = false . 

  ---- Aggregate average query rate exceeds k × initial average query rate for n consecutive time bins of width s
  ---- More clearly, we check avgQPS over n consecutive windows each of size T', shifted by bin size T'' 
  ----                   startT window/m bin/s th/k consecutive/n
  op alarm : TimeMsgList Float Float Float Float Int -> Bool .
  ceq alarm (TML, T, T', T'', TH, I) = 
      if highQPS(TML, T + (float(I) * T''), T', TH) 
      then alarm(TML, T, T', T'', TH, I - 1) 
      else false 
      fi 
    if I > 0 .
  eq alarm (TML, T, T', T'', TH, I) = true [owise].

  ---- time at which the alarm occurred (I bins after start time)
  op alarmTime : Float Float Float Int -> Float .
  eq alarmTime(T, T', T'', I) = T + T' + (float(I) * T'') .

  ----                 startT window/m bin/s th/k consecutive/n
  op tod : TimeMsgList Float Float Float Float Int -> Float .
  eq tod (TML ; tm(Tmsg, M), T, T', T'', TH, I) = 
    if  T >= Tmsg --- passed the end
      then 0.0
      else
        (if alarm(TML ; tm(Tmsg, M), T, T', T'', TH, I) 
          then alarmTime(T, T', T'', I)
          else tod(TML ; tm(Tmsg, M), T + T'', T', T'', TH, I) 
        fi) 
    fi
            --- if lastT(TML ; tm(Tmsg, M)) > alarmTime(T, T', T'', I - 1) 
            --- [print "ToD [" T "," T' "] bin " T'' ]
            . 

  op getInitialQPS : Config Float -> Float .
  eq getInitialQPS (C < ADDR : Adversary | sent: TML, attrs >, T) = avgQPS(TML, 0.0, T) .  

  op getAvgQPS : Config Float Float -> Float .
  eq getAvgQPS (C < ADDR : Adversary | sent: TML, attrs >, T, T') = avgQPS(TML, T, T') .  

  op getHcsQPS : Config Float -> Float .
  eq getHcsQPS (C < ADDR : Adversary | sent: TML, attrs >, T) = avgQPS(TML, T, lastT(TML) - T) .  

  --- MA.1 Aggregate post-NAT average DNS query rate exceeds k × initial TGEN-only average query rate for n consecutive time bins of width s.
                        --- init start window bin th consecutive
  op getToD : Config Float Float Float Float Int -> Float .
  eq getToD (C < ADDR : Adversary | sent: TML, attrs >, T'', T, T', TH, I) = tod(TML, T'' - T, T, T', TH, I) . 

                        --- init start window bin th consecutive
  op isDetected : Config Float Float Float Float Int -> Bool .
  eq isDetected (C < ADDR : Adversary | sent: TML, attrs >, T'', T, T', TH, I) = if tod(TML, T'' - T, T, T', TH, I) > 0.0 then true else false fi . 

  ---- get the avg qps for each window
  op perWindowQPS : TimeMsgList Float Float Float -> List{Float} .
  op $perWindowQPS : TimeMsgList Float Float Float List{Float} -> List{Float} .
  eq  perWindowQPS(TML, T, T', T'') = $perWindowQPS(TML, T, T', T'', nil) .
  eq $perWindowQPS(nilTML, T, T', T'', LF) = nil .
  eq $perWindowQPS(TML ; tm(Tmsg, M), T, T', T'', LF) = 
    if T >= Tmsg --- passed the end
      then LF
      ---- append average of this window and go to next window
      else $perWindowQPS(TML ; tm(Tmsg, M), T + T'', T', T'', (LF avgQPS(TML ; tm(Tmsg, M), T, T')))
    fi
    .
  
  ----                        startT window bin -> List of values one per window
  op getPerWindowQPs : Config Float Float Float -> List{Float} .
  eq getPerWindowQPs (C < ADDR : Adversary | sent: TML, attrs >, T, T', T'') = perWindowQPS(TML, T, T', T'') . 

  var ID : Id .
  var NAME : Name .
  var RTYPE : RType .
  vars B1 B2 : Bool .
  vars ALICE BOB : Address .
  vars N1 N2 N3 N4 N5 : Nat .

  op size : Name -> Nat .
  eq size (nm(fragment(ALICE, BOB, bytes, N1, N2, N3, N4, N5, B1, B2)) . NAME) = N5 + nameLength(NAME) .
  eq size (NAME) = nameLength(NAME) [owise] .

  op size : Query -> Nat .
  eq size (query(ID, NAME, RTYPE)) = size(NAME) .

  op size : TimeMsgList -> Nat .
  eq size (nilTML) = 0 .
  eq size (TML ; tm(T, M)) = size(getQuery(M)) + size(TML) .

  op sizeTimeWindow : TimeMsgList Float Float -> Nat .
  eq sizeTimeWindow (nilTML, T', T'') = 0 .
  eq sizeTimeWindow (TML ; tm(T, M), T', T'') = if T > T' and T < T'' then size(getQuery(M)) + sizeTimeWindow(TML, T', T'') else sizeTimeWindow(TML, T', T'') fi .

                            --- start window 
  op avgQuerySize : TimeMsgList Float Float -> Float .
  eq avgQuerySize (TML, T, T') = if float(lengthTimeWindow(TML, T, T + T')) > 0.0 then float(sizeTimeWindow(TML, T, T + T')) / float(lengthTimeWindow(TML, T, T + T')) else 0.0 fi .

  op getAvgQuerySize : Config -> Float .
  eq getAvgQuerySize (C < ADDR : Adversary | sent: TML, attrs >) = float(size(TML)) / float(length(TML)) .

  op getHcsQuerySize : Config Float -> Float .
  eq getHcsQuerySize (C < ADDR : Adversary | sent: TML, attrs >, T) = avgQuerySize(TML, T, lastT(TML) - T) .  

  ----- the average query size in window [T, T+T'] > th*(average query size in window [0, T'])
                        --- startT window threshold
  op highQuerySize : TimeMsgList Float Float Float -> Bool .
  eq highQuerySize (TML, T, T', TH) =
      if avgQuerySize (TML, T,  T') > avgQuerySize (TML, 0.0, T') * TH
      then true
      else false
      fi .
  eq highQuerySize (nilTML, T, T', TH) = false .

  ---- Aggregate average query rate exceeds k × initial average query rate for n consecutive time bins of width s
  ---- More clearly, we check avgQPS over n consecutive windows each of size T', shifted by bin size T''
  ----                   startT window/m bin/s th/k consecutive/n
  op alarmQuerySize : TimeMsgList Float Float Float Float Int -> Bool .
  ceq alarm (TML, T, T', T'', TH, I) =
      if highQuerySize(TML, T + (float(I) * T''), T', TH)
      then alarmQuerySize(TML, T, T', T'', TH, I - 1)
      else false
      fi
    if I > 0 .
  eq alarmQuerySize (TML, T, T', T'', TH, I) = true [owise].

  ----                 startT window/m bin/s th/k consecutive/n
  op todQuerySize : TimeMsgList Float Float Float Float Int -> Float .
  eq todQuerySize (TML ; tm(Tmsg, M), T, T', T'', TH, I) =
    if  T >= Tmsg --- passed the end
      then 0.0
      else
        (if alarmQuerySize(TML ; tm(Tmsg, M), T, T', T'', TH, I)
          then alarmTime(T, T', T'', I)
          else todQuerySize(TML ; tm(Tmsg, M), T + T'', T', T'', TH, I)
        fi)
    fi
            --- if lastT(TML ; tm(Tmsg, M)) > alarmTime(T, T', T'', I - 1)
            --- [print "ToD [" T "," T' "] bin " T'' ]
            .

  --- MA.2 Aggregate post-NAT average DNS query size exceeds k × initial TGEN-only average query size for n consecutive time bins of width s.
                        --- init start window bin th consecutive
  op getToDAvgQuerySize : Config Float Float Float Float Int -> Float .
  eq getToDAvgQuerySize (C < ADDR : Adversary | sent: TML, attrs >, T'', T, T', TH, I) = todQuerySize(TML, T'' - T, T, T', TH, I) .

  ---- get the avg query size for each window
  op perWindowQS : TimeMsgList Float Float Float -> List{Float} .
  op $perWindowQS : TimeMsgList Float Float Float List{Float} -> List{Float} .
  eq  perWindowQS(TML, T, T', T'') = $perWindowQS(TML, T, T', T'', nil) .
  eq $perWindowQS(nilTML, T, T', T'', LF) = nil .
  eq $perWindowQS(TML ; tm(Tmsg, M), T, T', T'', LF) = 
    if T >= Tmsg --- passed the end
      then LF
      ---- append average of this window and go to next window
      else $perWindowQS(TML ; tm(Tmsg, M), T + T'', T', T'', (LF avgQuerySize(TML ; tm(Tmsg, M), T, T')))
    fi
    .
  
  ----                        startT window bin -> List of values one per window
  op getPerWindowQS : Config Float Float Float -> List{Float} .
  eq getPerWindowQS (C < ADDR : Adversary | sent: TML, attrs >, T, T', T'') = perWindowQS(TML, T, T', T'') . 

  op AliceQuery : Name -> Bool .
  eq AliceQuery (nm(fragment(ALICE, BOB, bytes, N1, N2, N3, N4, N5, B1, B2)) . NAME) = true .
  eq AliceQuery (NAME) = false [owise] .

  op AliceQuery : Query -> Bool .
  eq AliceQuery (query(ID, NAME, RTYPE)) = AliceQuery(NAME) .

  op nthQueryTimePreNAT : TimeMsgList Nat -> Float .
  eq nthQueryTimePreNAT (TML, 0) = 0.0 .
  ceq nthQueryTimePreNAT (tm(T, M) ; TML, s 0) = T if AliceQuery(getQuery(M)) .
  eq nthQueryTimePreNAT (tm(T, M) ; TML, s N) = if AliceQuery(getQuery(M)) then nthQueryTimePreNAT(TML, N) else nthQueryTimePreNAT(TML, s N) fi .
  eq nthQueryTimePreNAT (nilTML, s N) = 0.0 .

  --- C.1 Pre-NAT earliest time cumulative number of queries > N
  op getToDCumulativeNQueryPreNAT : Config Nat -> Float .
  eq getToDCumulativeNQueryPreNAT (C < ADDR : Adversary | sent: TML, attrs >, N) = nthQueryTimePreNAT(TML, s N) .

  op nthQueryTimePostNAT : TimeMsgList Nat -> Float .
  eq nthQueryTimePostNAT (TML, 0) = 0.0 .
  eq nthQueryTimePostNAT (tm(T, M) ; TML, s 0) = T .
  eq nthQueryTimePostNAT (tm(T, M) ; TML, s N) = nthQueryTimePostNAT(TML, N) .
  eq nthQueryTimePostNAT (nilTML, s N) = 0.0 .

  --- C.2 Post-NAT earliest time cumulative number of queries > N
  op getToDCumulativeNQueryPostNAT : Config Nat -> Float .
  eq getToDCumulativeNQueryPostNAT (C < ADDR : Adversary | sent: TML, attrs >, N) = nthQueryTimePostNAT(TML, s N) .

  op nByteQueryTimePreNAT : TimeMsgList Nat -> Float .
  eq nByteQueryTimePreNAT (TML, 0) = 0.0 .
  eq nByteQueryTimePreNAT (tm(T, M) ; TML, N) = 
    if AliceQuery(getQuery(M)) then	
      (if size(getQuery(M)) > N then T else nByteQueryTimePreNAT(TML, N - size(getQuery(M))) fi) 
    else 
      nByteQueryTimePreNAT(TML, N) 
    fi .
  eq nByteQueryTimePreNAT (nilTML, N) = 0.0 .

  --- C.3 Pre-NAT earliest time cumulative size of queries > N
  op getToDCumulativeQuerySizePreNAT : Config Nat -> Float .
  eq getToDCumulativeQuerySizePreNAT (C < ADDR : Adversary | sent: TML, attrs >, N) = nByteQueryTimePreNAT(TML, N) .

  op nByteQueryTimePostNAT : TimeMsgList Nat -> Float .
  eq nByteQueryTimePostNAT (TML, 0) = 0.0 .
  eq nByteQueryTimePostNAT (tm(T, M) ; TML, N) = if size(getQuery(M)) > N then T else nByteQueryTimePostNAT(TML, N - size(getQuery(M))) fi .
  eq nByteQueryTimePostNAT (nilTML, N) = 0.0 .

  --- C.4 Post-NAT earliest time cumulative size of queries > N
  op getToDCumulativeQuerySizePostNAT : Config Nat -> Float .
  eq getToDCumulativeQuerySizePostNAT (C < ADDR : Adversary | sent: TML, attrs >, N) = nByteQueryTimePostNAT(TML, N) .

  op iByteQueryTime : TimeMsgList Nat -> Float .
  eq iByteQueryTime (TML, 0) = 0.0 .
  eq iByteQueryTime (tm(T, M) ; TML, N) = if size(getQuery(M)) > N then T else iByteQueryTime(TML, N) fi .
  eq iByteQueryTime (nilTML, N) = 0.0 .

  --- earliest time size of an individual query > N
  op getToDQuerySize : Config Nat -> Float .
  eq getToDQuerySize (C < ADDR : Adversary | sent: TML, attrs >, N) = iByteQueryTime(TML, N) .

endm
