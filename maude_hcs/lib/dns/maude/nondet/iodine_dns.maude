--- MAUDE_HCS: maude_hcs
---
--- Software Markings (UNCLASS)
--- PWNDD Software
---
--- Copyright (C) 2025 RTX BBN Technologies Inc. All Rights Reserved
---
--- Contract No: HR00112590083
--- Contractor Name: RTX BBN Technologies Inc.
--- Contractor Address: 10 Moulton Street, Cambridge, Massachusetts 02138
---
--- The U.S. Government's rights to use, modify, reproduce, release, perform,
--- display, or disclose these technical data and software are defined in the
--- Article VII: Data Rights clause of the OTA.
---
--- This document does not contain technology or technical data controlled under
--- either the U.S. International Traffic in Arms Regulations or the U.S. Export
--- Administration Regulations.
---
--- DISTRIBUTION STATEMENT A: Approved for public release; distribution is
--- unlimited.
---
--- Notice: Markings. Any reproduction of this computer software, computer
--- software documentation, or portions thereof must also reproduce the markings
--- contained herein.
---
--- MAUDE_HCS: end

load _aux
load ../../../../deps/dns_formalization/Maude/src/nondet-model/dns

mod IODINE_DNS is
  inc IAUX + DNS .


  vars ADDR ADDR1 ADDR2 NS RESOLVER ALICE BOB : Address .
  var RCODE : Nat .
  vars ANS AUTH ADD : List{Record} .
  vars wattrs wattrs1 wattrs2 wattrsNext wattrsTrans wattrsTrans' appAttrs appAttrs1 : AttributeSet .
  vars conf : Config .
  vars appAlice appBob wrappedNS : Actor .
  vars ID ID' : Id .      ---- Nat < Id
  vars NAME NAME' WNAME SNAME QNAME : Name .
  vars Q1 Q : Query .
  var QTYPE : RType .
  var  MIA MIA1 : MapIdAddr . 
  vars msgs msgs0 : Config .   ---- MsgConfig
  vars msg msg0 msg1 msgIn msgOut msgOutExt appMsgOut : Msg .
  vars queueSet txComplete maxAttemptsReached : Bool .
  vars PACKET_LIST' PACKET_LIST PACKETS PACKETS' : PacketList .
  var FRAGMENT_LIST : FragmentList .
  var Pkt : Packet .

  op fileSize : -> Nat .
  op packetSize : -> Nat .
  --------------------------------
  --- [WNameserver] --- Weird/wrapped Nameserver Rules
  --------------------------------

----  receivs DNS query with standard name
----  passthrough
----  TODO: merge into single rule below 
crl [wnameserver-receive-query-passthru]:
  < ADDR : WNameserver | wattrs,  
          conf: (wrappedNS)
  >
  (to ADDR from ADDR1 : query(ID, QNAME, QTYPE))
  =>
  < ADDR : WNameserver | wattrs, 
          conf: (wrappedNS (to ADDR from ADDR1 : query(ID, QNAME, QTYPE))) 
  >
  if  not isWeird(wattrs, (to ADDR from ADDR1 : query(ID, QNAME, QTYPE))) .

----  receivs DNS query response from my nameserver
----  passthrough
rl [weird-nameserver-response-passthru]:
  < ADDR : WNameserver | wattrs,  
          conf: (wrappedNS (to ADDR1 from ADDR : response(ID, SNAME, ANS, AUTH, ADD, RCODE)))
  >
  =>
  < ADDR : WNameserver | wattrs, 
          conf: (wrappedNS) 
  >
  (to ADDR1 from ADDR : response(ID, SNAME, ANS, AUTH, ADD, RCODE))  
  .

----  receivs DNS query with weird name
----  the WNS implements its own DNS logic and responds directly
----    without relying on the wrapped NS; this may challenge
----    our modularity assumptions and modeling
----  Steps are as follows:
----  1.  add fragment to fragment list 
----  2.  respond acking the fragment
----  3.  if last fragment also defrag and send message to Bob
----  TODO: add support for NULL QTYPE which is what will be used in tests
---- TODO: ideally WNS would remove the weird name and pass the query to wrappedNS 
----      but that is not how iodine is implemented! For now, iodine directly responds.
crl [wnameserver-receive-query-weird]:
  < ADDR : WNameserver | wattrs,  
          conf: (wrappedNS)
  >
  (to ADDR from ADDR1 : query(ID, QNAME, QTYPE))
  =>
  < ADDR : WNameserver | wattrs2,
          conf: (wrappedNS) 
  >
  msgOut 
  (if appMsgOut == nullMsg then null else appMsgOut fi)
  if isWeird(wattrs, (to ADDR from ADDR1 : query(ID, QNAME, QTYPE)))
  --- step 1 and step 2
  /\ {wattrs1, msgOut} := extractS(wattrs, (to ADDR from ADDR1 : query(ID, QNAME, QTYPE)))
  --- step 3
  /\ {wattrs2, appMsgOut} := updateRcvApp(wattrs1, (to ADDR from ADDR1 : query(ID, QNAME, QTYPE)))
  .

  ---------------------------------------
  --- [Receive App] --- Bob
  ---------------------------------------
  rl [receive-app-rcv-packet]:
    < ADDR : RcvApp | rcvd: PACKETS, appAttrs >
    (to ADDR from ADDR1 : Pkt)
  => 
    < ADDR : RcvApp | rcvd: (Pkt ; PACKETS), appAttrs > .

  ---------------------------------------
  --- [Send App] --- Alice
  ---------------------------------------
  crl [send-app-send-packet]:
    < ALICE : SendApp | toAddr: ADDR, queuePopulated: queueSet, queue: PACKET_LIST, sent: PACKETS', appAttrs >
    (to ALICE : start)
  => 
    < ALICE : SendApp | toAddr: ADDR, queuePopulated: true, queue: PACKETS, sent: (Pkt ; PACKETS'), appAttrs >
    (to ADDR from ALICE : Pkt)
    *** Check if the packet queue needs to be filled.
    *** If so, packetize the file.
    if (Pkt ; PACKETS) := (if queueSet == true
                     then PACKET_LIST
                     else getFilePackets(packetize((appAttrs, queue: mtpl), ALICE, ADDR, fileSize, packetSize))
                     fi)
    .

  ---------------------------------------
  --- [WClient] --- Weird (Iodine) client
  ---------------------------------------
  --- Handle packet from Alice headed to Bob.
  --- If a packet is not currently being sent or numAttempts >= 2, then WClient
  --- can accept and handle the packet.
  --- (same as not sending or sending and numAttempts > 2)
  --- Handle the packet, fragment it, and send the first fragment.
  crl [iClientEmbedding]:
    < ADDR : WClient | wattrs >
    (to ADDR from ALICE : Pkt)
    =>
    < ADDR : WClient | wattrsNext >
    msgOut
    if (not isSending(wattrs) or getNumAttempts(wattrs) >= 2)
       /\ {wattrsNext, msgOut} := handleAndSend(wattrs, ADDR, Pkt)
---    [print "iClientEmbedding msg in"  msg]
---    [print "iClientEmbedding fragment out "  msgOut]
    .

  --- Handle a response from the resolver to WClient.
  --- Extract the ACK information and check this is for the fragment that was
  --- just sent (seqNo, fragNum match).
  --- If the packet transmission is complete (this was last fragment) then
  --- send ALICE a msg to send one more packet. (we do this only in the nondet model)
  --- Otherwise, send the next fragment to WNameServer.
  crl [iClientExtractFromServer]:
    < ADDR : WClient | resv: RESOLVER, wattrs >
      (to ADDR from RESOLVER : response(ID, SNAME, ANS, AUTH, ADD, RCODE))
    =>
    < ADDR : WClient | wattrsNext >
    (if msgOut == nullMsg then null else msgOut fi) 
    (if msgOutExt == nullMsg then null else msgOutExt fi)
    if wattrsTrans := extract((resv: RESOLVER, wattrs), response(ID, SNAME, ANS, AUTH, ADD, RCODE))
      /\ txComplete := isTxComplete(wattrsTrans)
      /\ {wattrsNext, msgOutExt} :=
        if txComplete
          then {wattrsTrans, nullMsg}
          else sendFragment(wattrsTrans, ADDR)
        fi
      /\ (wattrs1, appAddrMap: MIA) := wattrsNext
      --- frag corresponding to this response/query id came originally from ALICE
      /\ ((ID <~ ALICE) !! MIA1) := MIA 
      /\ msgOut := 
        if txComplete
        --- TODO: extract ALICE address from response also to know to send to Alice
          then (to ALICE : start)
          else nullMsg
        fi
    .

endm
