load _aux
load ../../../deps/dns_formalization/Maude/src/nondet-model/dns

mod IODINE_DNS is
  inc DNS + IODINE_NODE .


  vars ADDR ADDR1 ADDR2 NS ALICE BOB : Address .
  var RCODE : Nat .
  vars ANS AUTH ADD : List{Record} .
  vars wattrs wattrs1 wattrs2 wattrsNext wattrsTrans wattrsTrans' appAttrs appAttrs1 : AttributeSet .
  vars conf : Config .
  vars appAlice appBob wrappedNS : Actor .
  vars ID ID' : Id .      ---- Nat < Id
  vars NAME NAME' WNAME SNAME QNAME : Name .
  vars Q1 Q : Query .
  var QTYPE : RType .
  var  wdb : MapIdMsg . 
  vars msgs msgs0 : Config .   ---- MsgConfig
  vars msg msg0 msg1 msgIn msgOut : Msg .
  --------------------------------
  --- [WNameserver] --- Weird/wrapped Nameserver Rules
  --------------------------------

----  receivs DNS query with standard name
----  passthrough
----  TODO: merge into single rule below 
crl [wnameserver-receive-query-passthru]:
  < ADDR : WNameserver | wattrs,  
          conf: (appBob wrappedNS)
  >
  msg
  =>
  < ADDR : WNameserver | wattrs, 
          conf: (appBob wrappedNS msg) 
  >
  if not isWeird(wattrs, msg) .

----  receivs DNS query response from my nameserver
----  passthrough
rl [weird-nameserver-response-passthru]:
  < ADDR : WNameserver | wattrs,  
          conf: (appBob wrappedNS (to ADDR1 from ADDR : response(ID, SNAME, ANS, AUTH, ADD, RCODE)))
  >
  =>
  < ADDR : WNameserver | wattrs, 
          conf: (appBob wrappedNS) 
  >
  (to ADDR1 from ADDR : response(ID, SNAME, ANS, AUTH, ADD, RCODE))  
  .

----  receivs DNS query with weird name
----  the WNS implements its own DNS logic and responds directly
----    without relying on the wrapped NS; this may challenge
----    our modularity assumptions and modeling
----  Steps are as follows:
----  1.  add fragment to fragment list 
----  2.  respond acking the fragment
----  3.  if last fragment also defrag and send message to Bob
----  TODO: add support for NULL QTYPE which is what will be used in tests
crl [wnameserver-receive-query-weird]:
  < ADDR : WNameserver | wattrs,  
          conf: (< BOB : RcvApp | appAttrs > wrappedNS)
  >
  msg
  =>
  < ADDR : WNameserver | wattrs2,
          conf: (< BOB : RcvApp | appAttrs1 > wrappedNS) 
  >
  msgOut
  if isWeird(wattrs, msg)
  --- step 1 and step 2
  /\ {wattrs1, msgOut} := extractS(wattrs, msg)
  --- step 3
  /\ {wattrs2, appAttrs1} := updateRcvApp(wattrs1, appAttrs)
  .

  ---------------------------------------
  --- [WClient] --- Weird (Iodine) client
  ---------------------------------------
  --- Start Weird client.
---  rl [startWClient]:
---    < ADDR : WClient | wattrs, conf: appAlice > (to ALICE : start)
---    =>
---    < ADDR : WClient | wattrs, conf: (appAlice (to ALICE : start) ) >
---    [print "startWClient" ]
---    .
---
  crl [iClientEmbedding]:
    < ADDR : WClient | wattrs, conf: (< ALICE : SendApp | appAttrs > msg)
    >
    =>
    < ADDR : WClient | wattrsNext, conf: (< ALICE : SendApp | appAttrs >)
    >
    msgOut
    if (not isSending(wattrs) or getNumAttempts(wattrs) < 2)
       /\ {wattrsNext, msgOut} := handleAndSend(wattrs, msg)
---    [print "iClientEmbedding msg in"  msg]
---    [print "iClientEmbedding fragment out "  msgOut]
    .

--- TODO: Combine these with if then else
---  crl [iClientExtractLast]:
---    < ADDR : WClient | (wattrs, resv: RESOLVER), conf : (ALICE : SendApp) >
---      (to ALICE from RESOLVER : RESPONSE)
---    =>
---    < ADDR : WClient | wattrsNext, conf : (ALICE : SendApp) >
---      --- msgs  --- Can we send no message here?
---     TODO: Actually, we should send a message back to ALICE to send more.
--- Question: Are these propositions evaluated one after the other or all at once?  In other words, if last proposition is false, do the operations that happen in previous proposition get "undone?"
---    if wattrsTrans := extract(wattrs, RESPONSE)
---      /\ wattrsNext := isTxComplete(wattrTrans)
---    .

---  crl [iClientExtract]:
---    < ADDR : WClient | (wattrs, resv: RESOLVER), conf : (ALICE : SendApp) >
---      (to ALICE from RESOLVER : RESPONSE)
---    =>
---    < ADDR : WClient | wattrsNext, conf : (ALICE : SendApp) >
---      msg
---    if wattrsTrans := extract(wattrs, RESPONSE)
---      /\ wattrsTrans' := not isTxComplete(wattrTrans)
---      /\ {wattrsNext, msg} := sendFragment(wattrsTrans', BOB)    --- BOB is supposed to be coming from somewhere.  Where?
---    .

endm
