--- MAUDE_HCS: maude_hcs
---
--- Software Markings (UNCLASS)
--- PWNDD Software
---
--- Copyright (C) 2025 RTX BBN Technologies Inc. All Rights Reserved
---
--- Contract No: HR00112590083
--- Contractor Name: RTX BBN Technologies Inc.
--- Contractor Address: 10 Moulton Street, Cambridge, Massachusetts 02138
---
--- The U.S. Government's rights to use, modify, reproduce, release, perform,
--- display, or disclose these technical data and software are defined in the
--- Article VII: Data Rights clause of the OTA.
---
--- This document does not contain technology or technical data controlled under
--- either the U.S. International Traffic in Arms Regulations or the U.S. Export
--- Administration Regulations.
---
--- DISTRIBUTION STATEMENT A: Approved for public release; distribution is
--- unlimited.
---
--- Notice: Markings. Any reproduction of this computer software, computer
--- software documentation, or portions thereof must also reproduce the markings
--- contained herein.
---
--- MAUDE_HCS: end

load ../../../../deps/dns_formalization/Maude/dns/common/_aux
load ../../../common/maude/_aux

mod MYLISTS is
  *** TODO: Replace AUX-COMMON with just the needed packages.
  pr AUX-COMMON .
  pr RANDOM .
  pr BYTESEQ .

  ---- Lists of messages (sent or received by apps)
  --- sort MsgList .  
  --- subsort Msg < MsgList .

  --- var msg : Msg .
  --- var msgL : MsgList .
  
  --- op nilMsgList : -> MsgList [ctor] .
  --- op _;;_ : MsgList MsgList -> MsgList [ctor assoc id: nilMsgList] .

  --- op length : MsgList -> Nat .
  --- eq length(nilMsgList) = 0 .
  --- eq length(msg ;; msgL) = s length(msgL) .
  
  ---- Alice sends "UDP packets" to the TUN IFace
  ---- Each packet has a data len (application bytes being sent), and an id for tracking
  ---- The len determines how many "fragments" are needed to send the packet over DNS
  ---- A packet gets fragmented into 1 or more fragments
  ---- A fragment is what gets embedded into a DNS query
  ----   recall subsort Nat < Id 
  
  sorts Packet Fragment .
  sorts PacketList FragmentList .
  subsort Fragment < FragmentList .
  subsort Packet < PacketList .

  subsorts Packet Fragment < Content . 
  ----        AliceAddr BobAddr File Packet# DataLenBytes lastPacket? 
  op packet : Address Address ByteSeq Nat Nat Bool -> Packet .
  ----          AliceAddr BobAddr File Packet# Frag# DataLenBytes lastPacketlastFrag 
  op fragment : Address Address ByteSeq Nat Nat Nat Nat Nat Bool Bool -> Fragment .  

  vars curFragments FL : FragmentList .
  var F : Fragment .
  vars FILE : ByteSeq .
  var PL : PacketList .
  var P : Packet .
  vars FROM_ADDR TO_ADDR : Address .
  vars OUT_SEQNO OUT_FRAGNO IN_SEQNO IN_FRAGNO FRAG_LEN P_LEN : Nat .
  vars LAST_PACKET LAST_FRAG : Bool .

  op nilFragment : -> Fragment .
  op nilPacket : -> Packet .

  op mtfl    : -> FragmentList [ctor] .
  op mtpl    : -> PacketList [ctor] .
  op _:_    : FragmentList FragmentList -> FragmentList [ctor assoc id: mtfl] .
  op _;_    : PacketList PacketList -> PacketList [ctor assoc id: mtpl] .

  op getFromAddr : Fragment -> Address .
  eq getFromAddr(fragment(FROM_ADDR, TO_ADDR, FILE, OUT_SEQNO, OUT_FRAGNO, IN_SEQNO, IN_FRAGNO, FRAG_LEN, LAST_PACKET, LAST_FRAG)) = FROM_ADDR .

  op getFile : PacketList -> ByteSeq .
  --- TODO: This function should make sure that all packets are in.
  eq getFile(packet(FROM_ADDR, TO_ADDR, FILE, OUT_SEQNO, P_LEN, LAST_PACKET) ; PL) = FILE .
  eq getFile(mtpl) = nilBytes .

  ----        return list of fragments that form a packet
  ----          Packet HOSTNAME_LEN
  op makeFragments : Packet Nat -> FragmentList .
  ----          Packet HOSTNAME_LEN cur_frag_num cur_fragments
  op $makeFragments : Packet Nat Nat FragmentList -> FragmentList .

  ----        return packet from list of fragments 
  op makePacket : FragmentList ->  Packet .
  op $makePacket : FragmentList Packet ->  Packet .

  eq makeFragments(packet(FROM_ADDR, TO_ADDR, FILE, OUT_SEQNO, P_LEN, LAST_PACKET), FRAG_LEN) = 
    $makeFragments(packet(FROM_ADDR, TO_ADDR, FILE, OUT_SEQNO, P_LEN, LAST_PACKET), FRAG_LEN, 0, mtfl) .
  
  eq $makeFragments(packet(FROM_ADDR, TO_ADDR, FILE, OUT_SEQNO, P_LEN, LAST_PACKET), FRAG_LEN,  OUT_FRAGNO, curFragments) =
    if P_LEN > FRAG_LEN 
    then
      $makeFragments(packet(FROM_ADDR, TO_ADDR, FILE, OUT_SEQNO, (P_LEN + (- FRAG_LEN)), LAST_PACKET), FRAG_LEN, s OUT_FRAGNO, curFragments : fragment(FROM_ADDR, TO_ADDR, FILE, OUT_SEQNO, s OUT_FRAGNO, 0, 0, FRAG_LEN, LAST_PACKET, false)) 
    else 
      curFragments : fragment(FROM_ADDR, TO_ADDR, FILE, OUT_SEQNO, s OUT_FRAGNO, 0, 0, P_LEN, LAST_PACKET, true)
    fi  
    .

  eq makePacket(fragment(FROM_ADDR, TO_ADDR, FILE, OUT_SEQNO, OUT_FRAGNO, IN_SEQNO, IN_FRAGNO, FRAG_LEN, LAST_PACKET, LAST_FRAG) : curFragments) = 
    $makePacket(curFragments, packet(FROM_ADDR, TO_ADDR, FILE, OUT_SEQNO, FRAG_LEN, LAST_PACKET))  .
  eq $makePacket((fragment(FROM_ADDR, TO_ADDR, FILE, OUT_SEQNO, OUT_FRAGNO, IN_SEQNO, IN_FRAGNO, FRAG_LEN, LAST_PACKET, LAST_FRAG) : curFragments), packet(FROM_ADDR, TO_ADDR, FILE, OUT_SEQNO, P_LEN, LAST_PACKET)) =
    $makePacket(curFragments, packet(FROM_ADDR, TO_ADDR, FILE, OUT_SEQNO, (P_LEN + FRAG_LEN), LAST_PACKET)) .
  eq $makePacket(mtfl, P) = P .

  op length : FragmentList -> Nat .     
  
  eq length(mtfl) = 0 .
  eq length(F : FL) = s length(FL) .

  op popFront : FragmentList -> FragmentList .
  eq popFront(F : FL) = FL .
  eq popFront(mtfl) = mtfl .

  op peekFront : FragmentList -> Fragment .
  eq peekFront(F : FL) = F .
  eq peekFront(mtfl) = nilFragment .

endm

--- view FragmentList from TRIV to MYLISTS is
---   sort Elt to FragmentList .
--- endv

--- view PacketList from TRIV to MYLISTS is
---   sort Elt to PacketList .
--- endv

mod IODINE_SORTS is   
  pr MYLISTS .
---  inc META-LEVEL .
---  pr CONVERSION .
  
  vars FROM_ADDR TO_ADDR ADDR ADDR' : Address . 
  vars NAME NAME1 : Name .
  vars OUT_SEQNO OUT_FRAGNO IN_SEQNO IN_FRAGNO FRAG_LEN P_LEN : Nat .
  vars LAST_FRAG LAST_PACKET : Bool .  
  var ID : Id .
  var QTYPE : RType .
  var ANS AUTH ADD : List{Record} .
  var RCODE : Nat .
  var F : Fragment .
  var RESPONSE : Response .
  var FILE : ByteSeq .

  --- convert a fragment into a Name to be embedded
  op nm : Fragment -> Name .  
  --- convert back to fragment
  op fragment : Name -> Fragment .    

  --- convert a fragment into a Qid to be embedded
  --- op toQId : Fragment -> Qid .
  --- op toQId : Qid Nat Nat Nat -> Qid .
  --- eq toQId(fragment(QID1, N, N1, N2)) = toQId(QID1, N, N1, N2) .
  --- eq toQId(QID1, N, N1, N2) = qid(string(QID1) + "#" + string(N,10) + "#" + string(N1, 10) + "#" + string(N2, 10)) .
  
  eq fragment(nm(fragment(FROM_ADDR, TO_ADDR, FILE, OUT_SEQNO, OUT_FRAGNO, IN_SEQNO, IN_FRAGNO, FRAG_LEN, LAST_PACKET, LAST_FRAG))) = fragment(FROM_ADDR, TO_ADDR, FILE, OUT_SEQNO, OUT_FRAGNO, IN_SEQNO, IN_FRAGNO, FRAG_LEN, LAST_PACKET, LAST_FRAG) .
  eq fragment(NAME) = nilFragment [owise] .

  op getFromAddr : Response -> Address .
  ceq getFromAddr(response(ID, NAME, ANS, AUTH, ADD, RCODE)) = ADDR
    if nm(F) . NAME1 := NAME
      /\ ADDR := getFromAddr(F)
  .
  
  op getResponse : Msg -> Response .
  eq getResponse((to ADDR from ADDR' : RESPONSE)) = RESPONSE .

  ---- Get the outgoing sequence number of a fragment
  op getFragOutSeqNo : Fragment -> Nat .
  eq getFragOutSeqNo(fragment(FROM_ADDR, TO_ADDR, FILE, OUT_SEQNO, OUT_FRAGNO, IN_SEQNO, IN_FRAGNO, FRAG_LEN, LAST_PACKET, LAST_FRAG)) = OUT_SEQNO .

  ---- Get the outgoing fragment number of a fragment
  op getFragOutFragNo : Fragment -> Nat .
  eq getFragOutFragNo(fragment(FROM_ADDR, TO_ADDR, FILE, OUT_SEQNO, OUT_FRAGNO, IN_SEQNO, IN_FRAGNO, FRAG_LEN, LAST_PACKET, LAST_FRAG)) = OUT_FRAGNO .

  op getToAddr : Fragment -> Address .
  eq getToAddr(fragment(FROM_ADDR, TO_ADDR, FILE, OUT_SEQNO, OUT_FRAGNO, IN_SEQNO, IN_FRAGNO, FRAG_LEN, LAST_PACKET, LAST_FRAG)) = TO_ADDR .

  op getToAddr : Query -> Address .
  ceq getToAddr(query(ID, NAME, QTYPE)) = ADDR
    if nm(F) . NAME1 := NAME
      /\ ADDR := getToAddr(F)
  .

  op isLastFragment : Fragment -> Bool .
  eq isLastFragment(fragment(FROM_ADDR, TO_ADDR, FILE, OUT_SEQNO, OUT_FRAGNO, IN_SEQNO, IN_FRAGNO, FRAG_LEN, LAST_PACKET, LAST_FRAG)) = LAST_FRAG .

  op isLastFragment : Name -> Bool .
  eq isLastFragment(nm(F) . NAME1) = isLastFragment(F) .

  op getPacketLength : Packet -> Nat .
  eq getPacketLength(packet(FROM_ADDR, TO_ADDR, FILE, OUT_SEQNO, P_LEN, LAST_FRAG)) = P_LEN .

  op isLastPacket : Packet -> Bool .
  eq isLastPacket(packet(FROM_ADDR, TO_ADDR, FILE, OUT_SEQNO, P_LEN, LAST_FRAG)) = LAST_FRAG .

endm  
--- these views allow us to create lists LIST{X} where X is sort Packet or Fragment
--- view Packet from TRIV to IODINE_SORTS is sort Elt to Packet . endv
--- view Fragment from TRIV to IODINE_SORTS is sort Elt to Fragment . endv



mod IODINE_AUX is
  pr IODINE_SORTS .
  pr CP2_SORTS .
  --- pr LIST{Packet} .
---  pr LIST{Fragment} .
  
  sorts MapIdAddr  IdAddr .
  subsort IdAddr < MapIdAddr .
  
  vars OUT_SEQNO OUT_FRAGNO IN_SEQNO IN_FRAGNO FRAG_LEN P_LEN : Nat .
  var LAST_FRAG LAST_PACKET : Bool .
  ---var curFragments : List{Fragment} .
  var curFragments : FragmentList .
  var Pkt Pkt1 : Packet .
  var Frag Frag1 : Fragment .
  var FROM_ADDR TO_ADDR : Address .

  var wdb : MapIdAddr .
  var ID : Id .
  var ADDR ADDR1 : Address .
---  var msg : Config .
---  var Attrs : AttributeSet .
---
---  op nullMsg : -> Msg .
---
---  ---- Used by iodine server when extracting information from Query
---  sort AttributeSetMsgs .
---  sort AttributeSetPair .
---  ----              serverAttrs Msgs
---  op `{_`,_`} : AttributeSet Config -> AttributeSetMsgs [ctor] .  
---  ----              serverAttrs appAttrs
---  op `{_`,_`} : AttributeSet AttributeSet -> AttributeSetPair [ctor] .
---
---  op getAttributes : AttributeSetMsgs -> AttributeSet .
---  eq getAttributes({Attrs, msg}) = Attrs .

---  op getMsg : AttributeSetMsgs -> Config .
---  eq getMsg({Attrs, msg}) = msg .

  op _<~_ : Id Address -> IdAddr [ctor] .
  op mtIdAddr : -> MapIdAddr .
  op  _!!_ : MapIdAddr MapIdAddr -> MapIdAddr
                 [ctor assoc comm id: mtIdAddr] .
  op updateMap : MapIdAddr Id Address -> MapIdAddr .
  eq updateMap(wdb !! (ID <~ ADDR), ID, ADDR1) 
          = wdb !! (ID <~ ADDR1) .
  eq updateMap(wdb,ID,ADDR) = wdb !! (ID <~ ADDR) [owise] .

endm

mod IODINE_NODE is
  inc IODINE_AUX .

  var wattrs wattrsNext wattrsTrans wattrsTrans' Attrs AttrsTrans Attrs1 Attrs2 Attrs3 : AttributeSet .
  vars CONF CONF1 : Config .
  var msg msgIn msgOut : Msg .
  var NAME NAME1 NAME' : Name .
  var F : Fragment .
  var F' : Fragment .
  var ADDR ADDR1 AliceAddr BobAddr RESOLVER FROM_ADDR : Address .
  var ID : Id .
  var QTYPE : RType .
  vars NUM_ATTEMPTS NUM_FRAGS : Nat .
  var LAST_FRAG LAST_PACKET : Bool .
  vars OUT_SEQNO QUERY_CTR OUT_FRAGNO IN_SEQNO IN_FRAGNO : Nat .
  vars N N1 N2 P_LEN HOSTNAME_LEN : Nat .
  vars FRAGMENT_LIST FRAGMENT_LIST' : FragmentList .
  var PACKET : Packet .
  vars PACKET_LIST PACKET_LIST' : PacketList .
  var db wDb : List{Record} .
  var QUERY : Query .
  var RESPONSE : Response .
  var ANS AUTH ADD : List{Record} .
  var RCODE : Nat .
  var MIdAddr MIdAddr1 : MapIdAddr .
  var IdA IdA1 : IdAddr .
  vars IODINEREADY : Bool .
  vars FILE_SIZE PKT_SIZE PKT_COUNTER PktSize : Nat .
  --- TODO: refactor as RDATA (response data?) since it's more concise
  var downstreamdata : RData .
  var sTTL : Float .
  vars FILE : ByteSeq .

--------  Nesting/Meta configuration  attribute
  op conf:_ : Config -> Attribute [ctor] .
  
  op getQuery : Msg -> Query .
  eq getQuery((to ADDR from ADDR1 : QUERY)) = QUERY .

  op getPkt : Msg -> Packet .
  eq getPkt((to ADDR from ADDR1 : PACKET)) = PACKET .

  ------------------------------------------------------
  --- [App Alice] --- 
  ---  Alice sends weird messages to Bob via WNameserver
  ------------------------------------------------------
  op SendApp : -> ActorType [ctor] .  
  --- file destination
  op fileDestAddr:_ : Address -> Attribute [ctor] .
  --- who to send to? (the iodine client)
  op toAddr:_ : Address -> Attribute [ctor] .
  --- bool indicating queue is ready (set to false if pre-populating queue).
  op queuePopulated:_ : Bool -> Attribute [ctor] .
  ---- packets to send
  op queue:_ : PacketList -> Attribute [ctor] . 
  ---- packets sent
  op sent:_ : PacketList -> Attribute [ctor] .
  --- bool indicating pacing interval passed
  op numAdmittedPkts:_ : Nat -> Attribute [ctor] .
  --- bool indicating wclient ready
  op iodineReady:_ : Bool -> Attribute [ctor] .
  --- The per-packet overhead in bytes.
  op packetOverhead : -> Nat .

  op makeSendApp : Address Address -> Actor [ctor] .
  eq makeSendApp(AliceAddr, BobAddr) =
    < AliceAddr : SendApp | toAddr: BobAddr, queue: mtpl, sent: mtpl > .

  op getFilePackets : AttributeSet -> PacketList .
  eq getFilePackets(Attrs, queue: PACKET_LIST) = PACKET_LIST .

  op getNumAdmittedPkts : AttributeSet -> Nat .
  eq getNumAdmittedPkts(Attrs, numAdmittedPkts: N) = N .

  op isIodineReady : AttributeSet -> Bool .
  eq isIodineReady(Attrs, iodineReady: IODINEREADY) = IODINEREADY .

  op sendPkt : AttributeSet Address -> AttributeSetMsgs .
  ceq sendPkt((Attrs, toAddr: ADDR, queue: (PACKET ; PACKET_LIST), sent: PACKET_LIST', numAdmittedPkts: N, iodineReady: IODINEREADY), FROM_ADDR)  =
    {Attrs3, msgOut}
    if Attrs3 := (Attrs, toAddr: ADDR, queue: PACKET_LIST, sent: (PACKET ; PACKET_LIST'), numAdmittedPkts: if N > 0 then sd(N,1) else 0 fi, iodineReady: false)
      /\ msgOut := (to ADDR from FROM_ADDR : PACKET)
  .
  eq sendPkt(Attrs, FROM_ADDR) = {Attrs, nullMsg} [owise] .

  ---            Attributes   Src     Dest    File PacketSize
  op packetize : AttributeSet Address Address ByteSeq Nat -> AttributeSet .
  eq packetize((Attrs, queue: PACKET_LIST), AliceAddr, BobAddr, FILE, PKT_SIZE) = (Attrs, queue: $packetize(mtpl, AliceAddr, BobAddr, FILE, getSize(FILE), PKT_SIZE, 0))
  .

  ---          CurrentPktList Src   Dest   FileSize PktSize Counter
  op $packetize : PacketList Address Address ByteSeq Nat Nat Nat -> PacketList .
  eq $packetize(PACKET_LIST, AliceAddr, BobAddr, FILE, FILE_SIZE, PKT_SIZE, PKT_COUNTER) = 
      (if FILE_SIZE > PKT_SIZE
       then
         $packetize(PACKET_LIST ; packet(AliceAddr, BobAddr, FILE, PKT_COUNTER, PKT_SIZE + packetOverhead, false), AliceAddr, BobAddr, FILE, FILE_SIZE + (- PKT_SIZE), PKT_SIZE, s PKT_COUNTER)
       else
         (PACKET_LIST ; packet(AliceAddr, BobAddr, FILE, PKT_COUNTER, FILE_SIZE + packetOverhead, true))
       fi)
    .

  --------------------------------
  --- [App Bob] --- 
  ---   Bob receives weird messages from WNameserver
  --------------------------------
  op RcvApp : -> ActorType [ctor] .
  op rcvd:_ : PacketList  -> Attribute [ctor] .
  op fileDestAddr:_ : Address -> Attribute [ctor] .
  op fileSrcAddr:_ : Address -> Attribute [ctor] .
  --- who to send to? (the iodine client)
  op toAddr:_ : Address -> Attribute [ctor] .
  --- bool indicating queue is ready (set to false if pre-populating queue).
  op queuePopulated:_ : Bool -> Attribute [ctor] .
  ---- packets to send
  op queue:_ : PacketList -> Attribute [ctor] . 
  ---- packets sent
  op sent:_ : PacketList -> Attribute [ctor] .
  --- bool indicating pacing interval passed
  op numAdmittedPkts:_ : Nat -> Attribute [ctor] .
  --- bool indicating wclient ready
  op iodineReady:_ : Bool -> Attribute [ctor] .

  **** constructor for making receiver app actor
  op mkRcvApp : Address  -> Actor [ctor] .  
  eq mkRcvApp(BobAddr) =
    < BobAddr : RcvApp | rcvd: mtpl > .  

  ----------------
  --- [WCLIENT] ---  Client wrapper  -- alternate view
**** wclient = < clId : WDNSClient | wattrs 
****              conf: (< appId : WApp | attrs >  msgs) ?
**** contains app used by Alice to generate hidden msgs
----------------
  op WClient : -> ActorType [ctor] .

  --- the DNS resolver - should be know to weird client
  op resv:_ : Address -> Attribute [ctor] . 
  --- the base weird name to which hidden msg is attached
  op wDom:_ : Name -> Attribute [ctor] .
  --- store info about query  sent, pending response  
  ---op wDb:_ : MapIdMsg -> Attribute [ctor] .
  --- increment counter for each DNS query sent
  op queryCtr:_ : Nat -> Attribute [ctor] .
  --- increment counter for each packet being sent
  op outSeqNo:_ : Nat -> Attribute [ctor] .
  --- increment counter for each packet fragment being sent
  ---op fragmentCtr:_ : Nat -> Attribute [ctor] .
  --- fragment list, its size, and the current fragment being sent
  op fragmentsToSend:_ : FragmentList -> Attribute [ctor] .  
  --- Looks obsolete.  TODO: Remove?
  op fragmentsSize:_ : Nat -> Attribute [ctor] .
  op outFragNo:_ : Nat -> Attribute [ctor] .
  --- number of retransmissions of current fragment
  op numAttempts:_ : Nat -> Attribute [ctor] . 
  --- The query type.
  op weirdQType:_ : RType -> Attribute [ctor] .  
  --- MAP from query id to app address to track where to send responses
  op appAddrMap:_ : MapIdAddr -> Attribute [ctor] .

  op fragmentsReceived:_ : FragmentList -> Attribute [ctor] .

  --- The maximum fragment length (or fragment size).
  op maxFragmentLen : -> Nat .
  --- The maximum number of fragment transmission tries.
  op maxFragmentTx : -> Nat .

  op getResolver : AttributeSet ~> Address .
  eq getResolver(wattrs, resv: ADDR) = ADDR .

  op getFileSrcAddr : AttributeSet ~> Address .
  eq getFileSrcAddr(wattrs, fileSrcAddr: ADDR) = ADDR .

  op getWDom : AttributeSet Address ~> Name .
  eq getWDom((wattrs, wDom: NAME), ADDR) = NAME .

  op getWDom : AttributeSet ~> Name .
  eq getWDom(wattrs, wDom: NAME) = NAME .

  op getOutSeqNo : AttributeSet -> Nat .
  eq getOutSeqNo(wattrs, outSeqNo: OUT_SEQNO) = OUT_SEQNO .

  --- Get the sequence number of the last received fragment
  op getInSeqNo : AttributeSet -> Nat .
  eq getInSeqNo(wattrs, inSeqNo: IN_SEQNO) = IN_SEQNO .

  --- Get the fragment number of the last received fragment
  op getInFragNo : AttributeSet -> Nat .
  eq getInFragNo(wattrs, inFragNo: IN_FRAGNO) = IN_FRAGNO .

  --- Get the fragment number of the last sent fragment
  op getOutFragNo : AttributeSet -> Nat .
  eq getOutFragNo(wattrs, outFragNo: OUT_FRAGNO) = OUT_FRAGNO .

  op dropFragmentsToSend : AttributeSet -> AttributeSet .
  eq dropFragmentsToSend(wattrs, fragmentsToSend: FRAGMENT_LIST, numAttempts: NUM_ATTEMPTS) = wattrs, fragmentsToSend: mtfl, numAttempts: 0 .
  eq dropFragmentsToSend(wattrs) = wattrs [owise] .

  op isSending : AttributeSet -> Bool .
  eq isSending(wattrs, fragmentsToSend: FRAGMENT_LIST) =
    if length(FRAGMENT_LIST) > 0
      then true 
    else
      false
    fi
    .
  eq isSending(wattrs) = false [owise] .

  op isMaxAttemptsReached : AttributeSet -> Bool .
  eq isMaxAttemptsReached(wattrs) = getNumAttempts(wattrs) > maxFragmentTx .

  --- Increment the query id.
  --- Iodine increments queries by 7727.
  op incrQueryCtr : AttributeSet -> AttributeSet .
  eq incrQueryCtr(wattrs, queryCtr: QUERY_CTR) = wattrs, (queryCtr: (QUERY_CTR + 7727)) .
  eq incrQueryCtr(wattrs) = wattrs [owise] .

  --- Get the query id.
  op getQueryCtr : AttributeSet -> Nat .
  eq getQueryCtr(wattrs, queryCtr: QUERY_CTR) = QUERY_CTR .

  --- Get the number of attempts for the current fragment.
  op getNumAttempts : AttributeSet -> Nat .
  eq getNumAttempts(wattrs, numAttempts: NUM_ATTEMPTS) = NUM_ATTEMPTS .

  op incrNumAttempts : AttributeSet -> AttributeSet .
  eq incrNumAttempts(wattrs, numAttempts: NUM_ATTEMPTS) = (wattrs, numAttempts: (s NUM_ATTEMPTS)) .
  eq incrNumAttempts(wattrs) = wattrs [owise] .

  --- Handle a new packet (from Alice) (and bail on an old one).
  ---                   wClient Attributes Packet Max hostname length
  op handleNewPacket : AttributeSet Packet Nat -> AttributeSet .
  ceq handleNewPacket((wattrs, outSeqNo: OUT_SEQNO, fragmentsToSend: FRAGMENT_LIST, fragmentsSize: NUM_FRAGS, outFragNo: OUT_FRAGNO, numAttempts: NUM_ATTEMPTS),
                      packet(ADDR, ADDR1, FILE, N, P_LEN, LAST_PACKET),
                      HOSTNAME_LEN) =
    wattrs, (outSeqNo: N), (fragmentsToSend: FRAGMENT_LIST'), (fragmentsSize: length(FRAGMENT_LIST'), (outFragNo: 1), (numAttempts: 0))
      if FRAGMENT_LIST' := makeFragments(packet(ADDR, ADDR1, FILE, N, P_LEN, LAST_PACKET), HOSTNAME_LEN) . 
  eq handleNewPacket(wattrs, PACKET, N) = wattrs [owise] .

  --- Move a fragment forward.
  op moveFragmentUp : AttributeSet -> AttributeSet .
  eq moveFragmentUp(wattrs, fragmentsToSend: FRAGMENT_LIST, outFragNo: OUT_FRAGNO, numAttempts: NUM_ATTEMPTS) =
    wattrs, fragmentsToSend: popFront(FRAGMENT_LIST), outFragNo: s OUT_FRAGNO, numAttempts: 0 .

  --- Check if transmission is complete.
  op isTxComplete : AttributeSet -> Bool .
  eq isTxComplete(wattrs, fragmentsToSend: FRAGMENT_LIST) = (length(FRAGMENT_LIST) == 0) .

  --- Grab a fragment to send.
  op grabCurrentFragment : AttributeSet -> Fragment .
  eq grabCurrentFragment(wattrs, fragmentsToSend: FRAGMENT_LIST) = peekFront(FRAGMENT_LIST) .
  eq grabCurrentFragment(wattrs) = nilFragment [owise] .

  --- Check fragment match.
  op isAckMatch : AttributeSet Fragment -> Bool .
  ----          AliceAddr  Packet# Frag# AckPacket# AckFrag# DataLenBytes lastFrag
  ceq isAckMatch(wattrs, fragment(ADDR, ADDR1, FILE, OUT_SEQNO, OUT_FRAGNO, IN_SEQNO, IN_FRAGNO, N, LAST_PACKET, LAST_FRAG)) = true
    if (getOutSeqNo(wattrs) == IN_SEQNO)
      /\ (getOutFragNo(wattrs) == IN_FRAGNO)
    .
  eq isAckMatch(wattrs, fragment(ADDR, ADDR1, FILE, OUT_SEQNO, OUT_FRAGNO, IN_SEQNO, IN_FRAGNO, N, LAST_PACKET, LAST_FRAG)) = false [owise] .

  --- Handle a packet (msg) and send the first fragment.
  op handleAndSend : AttributeSet Address Packet -> AttributeSetMsgs .
  ceq handleAndSend(wattrs, ADDR, PACKET) =
    {wattrsNext, msgOut}
    if wattrsTrans := handleNewPacket(wattrs, PACKET, maxFragmentLen)
      /\ {wattrsNext, msgOut} := sendFragment(wattrsTrans, ADDR)
    .

  op ackFragment : Fragment Nat Nat -> Fragment .
  eq ackFragment(fragment(ADDR, ADDR1, FILE, OUT_SEQNO, OUT_FRAGNO, N1, N2, N, LAST_PACKET, LAST_FRAG), IN_SEQNO, IN_FRAGNO) = 
    fragment(ADDR, ADDR1, FILE, OUT_SEQNO, OUT_FRAGNO, IN_SEQNO, IN_FRAGNO, N, LAST_PACKET, LAST_FRAG) .

  --- Send current fragment as a query.
  ---                   Attributes from
  op sendFragment : AttributeSet Address -> AttributeSetMsgs .
  ceq sendFragment((wattrs,  appAddrMap: MIdAddr, numAttempts: NUM_ATTEMPTS, weirdQType: QTYPE), ADDR) = 
    {(wattrsNext, appAddrMap: MIdAddr1, numAttempts: s NUM_ATTEMPTS, weirdQType: QTYPE), (to RESOLVER from ADDR : QUERY)}
    if RESOLVER := getResolver(wattrs)
      /\ wattrsNext := incrQueryCtr(wattrs)
      /\ ID := getQueryCtr(wattrsNext)
      /\ (inSeqNo: IN_SEQNO, inFragNo: IN_FRAGNO, Attrs) := wattrs
      /\ F := ackFragment(grabCurrentFragment(wattrsNext), IN_SEQNO, IN_FRAGNO)
      /\ NAME := nm(F) . getWDom(wattrsNext)
      /\ QUERY := query(ID, NAME, QTYPE)
      --- keep track of app address that resulted in this query Id 
      /\ MIdAddr1 := updateMap(MIdAddr, ID, getFromAddr(F))
    .

--- TODO: Is severWResponseTTL the right thing to record for client?
  --- Extract a response and move to next fragment if is current fragment ACK.
  op extract : AttributeSet Response -> AttributeSet .
  ceq extract(wattrs, response(ID, NAME, < NAME', QTYPE, sTTL, downstreamdata >, AUTH, ADD, RCODE)) = wattrsTrans
    if nm(F) := downstreamdata
    --- Check if the incoming fragment can be accepted into the pending fragment list, then process the upstream ACK that might be contained in the fragment
    --- This order was confirmed in client.c.
      /\ (fragmentsReceived: FRAGMENT_LIST, lastFragment: LAST_FRAG, inSeqNo: IN_SEQNO, inFragNo: IN_FRAGNO, severWResponseTTL: sTTL, fragmentsToSend: FRAGMENT_LIST', Attrs) := wattrs
      /\ wattrsNext := 
        (if (getFragOutSeqNo(F) =/= IN_SEQNO) or (getFragOutFragNo(F) <= IN_FRAGNO)
          then (if getFragOutSeqNo(F) > IN_SEQNO
                  then flushFragmentsReceived(wattrs, F)
                  else wattrs
                fi)
          else ((fragmentsReceived: (FRAGMENT_LIST : F), lastFragment: isLastFragment(F), inSeqNo: getFragOutSeqNo(F), inFragNo: getFragOutFragNo(F), severWResponseTTL: sTTL, fragmentsToSend: FRAGMENT_LIST'), Attrs)
          fi)
      /\ wattrsTrans := (if isAckMatch(wattrsNext, F) then moveFragmentUp(wattrsNext) else wattrsNext fi)
    .

  --------------------------------
  --- [WNameserver] --- Weird/wrapped Nameserver
  --------------------------------
  op WNameserver : -> ActorType [ctor] .  
  --- This is Bob's address; weird msgs will be forwarded to bob
  --- Bob listens on a UDP socket that the server sends to
  --- Alice's address will be in the query name
  ---- NOT USED TO START since Bob is my belly
  --- op appAddr:_ : Address -> Attribute  [ctor] .
  --- List of fragments currently being processed
  op fragmentsReceived:_ : FragmentList -> Attribute [ctor] .
  --- The current packet number being received.
  op inSeqNo:_ : Nat -> Attribute [ctor] .
  --- The last fragment number received.
  op inFragNo:_ : Nat -> Attribute [ctor] .
  op lastFragment:_ : Bool -> Attribute [ctor] .
  op severWResponseTTL:_ : Float -> Attribute [ctor] .

  op fragmentsToSend:_ : FragmentList -> Attribute [ctor] .  
  --- Looks obsolete.  TODO: Remove?
  op fragmentsSize:_ : Nat -> Attribute [ctor] .
  op outFragNo:_ : Nat -> Attribute [ctor] .
  --- number of retransmissions of current fragment
  op numAttempts:_ : Nat -> Attribute [ctor] . 

  --- op qRcd:_ : Config ->  Attribute [ctor] .  --- msgConf
       --- query msg pending response

  **** constructor for making a name server
  op mkNameServer : Address List{Record}  -> Actor [ctor] .  
  eq mkNameServer(ADDR, db) =
    < ADDR : Nameserver |
      db: db,
      queue: nilQueue,
      forwardonly: nullAddr,
      queriesFwd: nilTAQL >  .

  op isWeird : AttributeSet Msg -> Bool .
  ceq isWeird(wattrs, msg) = true
    if (to ADDR from  ADDR1 : query(ID, NAME, QTYPE)) := msg
    /\ nm(F) . NAME1 := NAME
    .
  eq isWeird(wattrs, msg) = false [owise] .
 


  ---- Server extract fragment
  op extractS : AttributeSet Config -> AttributeSetMsgs .
  ceq extractS(wattrs, (to ADDR from ADDR1 : query(ID, NAME, QTYPE))) = {wattrsNext, msg}
    if  nm(F) . NAME1 := NAME
    /\ (fragmentsReceived: FRAGMENT_LIST, lastFragment: LAST_FRAG, inSeqNo: IN_SEQNO, inFragNo: IN_FRAGNO, severWResponseTTL: sTTL, fragmentsToSend: FRAGMENT_LIST', numAttempts: NUM_ATTEMPTS, Attrs) := wattrs
    /\ wattrsTrans :=
        *** If this is a different seqNo, or a previous Fragment,
        (if (getFragOutSeqNo(F) =/= IN_SEQNO) or (getFragOutFragNo(F) <= IN_FRAGNO)
          *** then if the fragment is from a next packet,
          then (if getFragOutSeqNo(F) > IN_SEQNO
                  *** then keep only the new fragment, move packet forward.
                  then flushFragmentsReceived(wattrs, F)
                  *** else this fragment is a duplicate (ignore).
                  *** TODO: Do not ignore and send ACK
                  else wattrs
                fi)
          *** Else, this is the new fragment of the current packet, accept (move fragment number forward).
          *** TODO: This does not handle when the fragment number could be 2 or more past the last one.
          else ((fragmentsReceived: (FRAGMENT_LIST : F), lastFragment: isLastFragment(F), inSeqNo: getFragOutSeqNo(F), inFragNo: getFragOutFragNo(F), severWResponseTTL: sTTL, fragmentsToSend: FRAGMENT_LIST', numAttempts: NUM_ATTEMPTS), Attrs)
          fi)
    ---- simply ACK fragment (NAME contains fragment; RCODE 0 is success)
    --- If there's a fragment, grab it and embed in the reply. Otherwise, default to null
    --- TODO: Possible delay between receiving and ACKing?
    /\ wattrsTrans' := (if isAckMatch(wattrsTrans, F) then moveFragmentUp(wattrsTrans) else wattrsTrans fi)
    /\ F' := grabCurrentFragment(wattrsTrans') 
    --- TODO: Check what iodined.c does for a dataless fragment's sequence number/fragment
    --- If F' is nilFragment ie no more fragments left to send, ACK the client's fragment with a dataless fragment
    /\ downstreamdata := nm(ackFragment((if F' == nilFragment then fragment(getToAddr(F), getFromAddr(F), file(0), 0, 0, 0, 0, 0, false, false) else F' fi), getInSeqNo(wattrsTrans'), getInFragNo(wattrsTrans')))
    --- iodined.c:588: Only increment attempt counter if this is not a dataless fragment
    /\ wattrsNext := (if F' == nilFragment then wattrsTrans' else incrNumAttempts(wattrsTrans') fi)
    /\ msg := (to ADDR1 from ADDR : response(ID, NAME, < NAME, QTYPE, sTTL, downstreamdata >, nil, nil, 0))
    .

  *** Clear the previous fragments, keep only this newly received one, and start
  *** receiving the packet from there.
  op flushFragmentsReceived : AttributeSet Fragment -> AttributeSet .
  ceq flushFragmentsReceived(wattrs, F) = wattrsNext
    if (Attrs1, fragmentsReceived: FRAGMENT_LIST, lastFragment: LAST_FRAG, inSeqNo: IN_SEQNO, inFragNo: IN_FRAGNO) := wattrs
      /\ wattrsNext := (Attrs1, fragmentsReceived: (mtfl : F), lastFragment: isLastFragment(F),
                        inSeqNo: getFragOutSeqNo(F), inFragNo: getFragOutFragNo(F))
    .
  
  op updateRcvApp : AttributeSet Config -> AttributeSetMsgs .
  ceq updateRcvApp(wattrs, (to ADDR from ADDR1 : query(ID, NAME, QTYPE))) = {wattrsTrans, msg}
    ---- server attrs
    if (fragmentsReceived: FRAGMENT_LIST, lastFragment: LAST_FRAG, Attrs1) := wattrs
    --- ---- app attrs
    --- /\ (rcvd: PACKET_LIST, Attrs2) := Attrs
    ---- if ready to defragment clean up state else no change
    /\ wattrsTrans := 
      (if LAST_FRAG 
      then (fragmentsReceived: mtfl, lastFragment: false, Attrs1)
      else wattrs 
      fi)
    --- get the fragment
    /\ nm(F) . NAME1 := NAME
    ---- defragment and send packet to Bob
    /\ msg := 
      (if LAST_FRAG
      then (to getToAddr(F) from getFromAddr(F) : makePacket(FRAGMENT_LIST))
      else nullMsg
      fi)
      .

  *** Symmetric behavior to updateRcvApp but for DNS responses from the iodine server to client rather than queries.
  *** Determines if a full packet can be assembled from received packets. If so, assemble it and prepare the message to send to Alice
  op updateRcvAppAlice : AttributeSet Config -> AttributeSetMsgs .
  ceq updateRcvAppAlice(wattrs, (to ADDR from ADDR1 : response(ID, NAME, < NAME', QTYPE, sTTL, downstreamdata >, AUTH, ADD, RCODE))) = {wattrsTrans, msg}
    ---- server attrs
    if (fragmentsReceived: FRAGMENT_LIST, lastFragment: LAST_FRAG, Attrs1) := wattrs
    --- ---- app attrs
    --- /\ (rcvd: PACKET_LIST, Attrs2) := Attrs
    ---- if ready to defragment clean up state else no change
    /\ wattrsTrans := 
      (if LAST_FRAG 
      then (fragmentsReceived: mtfl, lastFragment: false, Attrs1)
      else wattrs 
      fi)
    --- get the fragment
    /\ nm(F) := downstreamdata
    ---- defragment and send packet to Alice
    /\ msg := 
      (if LAST_FRAG
      then (to getToAddr(F) from getFromAddr(F) : makePacket(FRAGMENT_LIST))
      else nullMsg
      fi)
      .
      
endm


mod PACKET_FRAGMENT_TEST is
  inc IODINE_NODE .

  ops AliceAddr BobAddr addrWNS cAddr : -> Address . 

  op wClientAttrs : -> AttributeSet .
  op TEST-FILE : -> ByteSeq .

  eq packetOverhead = 33 .
endm

set show advisories off .

eof

---set trace on .
set print attribute on .
  
red packetize((wClientAttrs, queue: mtpl), AliceAddr, BobAddr, file(2000, "test_file"), 530) ==
  (wClientAttrs,
    queue: (packet(AliceAddr, BobAddr, file(2000, "test_file"), 0, 530 + packetOverhead, false) ;
            packet(AliceAddr, BobAddr, file(2000, "test_file"), 1, 530 + packetOverhead, false) ;
            packet(AliceAddr, BobAddr, file(2000, "test_file"), 2, 530 + packetOverhead, false) ;
            packet(AliceAddr, BobAddr, file(2000, "test_file"), 3, 410 + packetOverhead, true))) .
red nm(fragment(AliceAddr, BobAddr, file(1000, "test_file"), 1, 1, 2, 2, 100, false, true)) . 'microsoft . 'com . root .
red fragment(nm(fragment(AliceAddr, BobAddr, file(100, "test_file"), 1, 1, 2, 2, 100, false, true))) ==  fragment(AliceAddr, BobAddr, file(100, "test_file"), 1, 1, 2, 2, 100, false, true) .
red fragment(label(1)) == nilFragment .

red makeFragments(packet(AliceAddr, BobAddr, file(100, "test_file"), 1, 100, false), 10) ==
  fragment(AliceAddr, BobAddr, file(100, "test_file"), 1, 1, 0, 0, 10, false, false) :
  fragment(AliceAddr, BobAddr, file(100, "test_file"), 1, 2, 0, 0, 10, false, false) :
  fragment(AliceAddr, BobAddr, file(100, "test_file"), 1, 3, 0, 0, 10, false, false) :
  fragment(AliceAddr, BobAddr, file(100, "test_file"), 1, 4, 0, 0, 10, false, false) :
  fragment(AliceAddr, BobAddr, file(100, "test_file"), 1, 5, 0, 0, 10, false, false) :
  fragment(AliceAddr, BobAddr, file(100, "test_file"), 1, 6, 0, 0, 10, false, false) :
  fragment(AliceAddr, BobAddr, file(100, "test_file"), 1, 7, 0, 0, 10, false, false) :
  fragment(AliceAddr, BobAddr, file(100, "test_file"), 1, 8, 0, 0, 10, false, false) :
  fragment(AliceAddr, BobAddr, file(100, "test_file"), 1, 9, 0, 0, 10, false, false) :
  fragment(AliceAddr, BobAddr, file(100, "test_file"), 1, 10, 0, 0, 10, false, true)
    .
red makePacket(fragment(AliceAddr, BobAddr, file(100, "test_file"), 1, 1, 0, 0, 10, false, false) :
                fragment(AliceAddr, BobAddr, file(100, "test_file"), 1, 2, 0, 0, 10, false, false) :
                fragment(AliceAddr, BobAddr, file(100, "test_file"), 1, 3, 0, 0, 10, false, false) :
                fragment(AliceAddr, BobAddr, file(100, "test_file"), 1, 4, 0, 0, 10, false, false) :
                fragment(AliceAddr, BobAddr, file(100, "test_file"), 1, 5, 0, 0, 10, false, false) :
                fragment(AliceAddr, BobAddr, file(100, "test_file"), 1, 6, 0, 0, 10, false, false) :
                fragment(AliceAddr, BobAddr, file(100, "test_file"), 1, 7, 0, 0, 10, false, false) :
                fragment(AliceAddr, BobAddr, file(100, "test_file"), 1, 8, 0, 0, 10, false, false) :
                fragment(AliceAddr, BobAddr, file(100, "test_file"), 1, 9, 0, 0, 10, false, false) :
                fragment(AliceAddr, BobAddr, file(100, "test_file"), 1, 10, 0, 0, 10, false, true)) 
    == packet(AliceAddr, BobAddr, file(100, "test_file"), 1, 100, false)  .

red getQueryCtr(incrQueryCtr(wClientAttrs, queryCtr: 10)) == 7737 .

red length(mtfl) == 0 .
red length(fragment(AliceAddr, BobAddr, file(100, "test_file"), 1, 1, 0, 0, 10, false, false) : fragment(AliceAddr, BobAddr, file(100, "test_file"), 1, 2, 0, 0, 10, false, false)) == 2 .

red length(popFront(makeFragments(packet(AliceAddr, BobAddr, TEST-FILE, 1, 100, false), 20))) == 4 .
red length(popFront(mtfl)) == 0 .

red peekFront(makeFragments(packet(AliceAddr, BobAddr, TEST-FILE, 1, 100, false), 20)) == fragment(AliceAddr, BobAddr, TEST-FILE, 1, 1, 0, 0, 20, false, false) .
red peekFront(mtfl) == nilFragment .

red handleNewPacket((wClientAttrs, outSeqNo: 2, fragmentsToSend: mtfl, fragmentsSize: 0, outFragNo: 0, numAttempts: 0),
                    packet(AliceAddr, BobAddr, file(1000, "test_file"), 5, 150, false), 200) .
red handleNewPacket((wClientAttrs, outSeqNo: 2),
                    packet(AliceAddr, BobAddr, file(1000, "test_file"), 5, 950, false), 200) .
red moveFragmentUp(wClientAttrs, fragmentsToSend: makeFragments(packet(AliceAddr, BobAddr, file(1000, "test_file"), 1, 100, false), 20), outFragNo: 0, numAttempts: 2) .

red grabCurrentFragment(wClientAttrs, fragmentsToSend: makeFragments(packet(AliceAddr, BobAddr, TEST-FILE, 1, 100, false), 20)) == fragment(AliceAddr, BobAddr, TEST-FILE, 1, 1, 0, 0, 20, false, false) .

red isAckMatch((wClientAttrs, outSeqNo: 44, outFragNo: 5), fragment(AliceAddr, BobAddr, TEST-FILE, 22, 3, 44, 5, 100, false, false)) == true .
red isAckMatch((wClientAttrs, outSeqNo: 44), fragment(AliceAddr, BobAddr, TEST-FILE, 22, 3, 44, 5, 100, false, false)) == false .

red isWeird((fragmentsReceived: mtfl), (to addrWNS from cAddr : query(1, nm(fragment(AliceAddr, BobAddr, TEST-FILE, 1, 1, 0, 0, 100, false, true)) . 'pwnd2 . 'com . root, a))) == true .
red extractS((fragmentsReceived: mtfl), (to addrWNS from cAddr : query(1, nm(fragment(AliceAddr, BobAddr, TEST-FILE, 1, 1, 0, 0, 100, false, true)) . 'pwnd2 . 'com . root, a))) .

red flushFragmentsReceived((fragmentsReceived: (fragment(AliceAddr, BobAddr, TEST-FILE, 2, 3, 5, 1, 10, false, false) :
                                              fragment(AliceAddr, BobAddr, TEST-FILE, 2, 4, 5, 2, 10, false, false)),
                          lastFragment: false, inSeqNo: 2, inFragNo: 4),
                          fragment(AliceAddr, BobAddr, TEST-FILE, 3, 1, 6, 2, 10, false, true)) ==
(fragmentsReceived: (mtfl : fragment(AliceAddr, BobAddr, TEST-FILE, 3, 1, 6, 2, 10, false, true)), lastFragment: true, inSeqNo: 3, inFragNo: 1) .

*** New fragment is not a duplicate, but the next and last fragment of packet.
red getAttributes(extractS((fragmentsReceived: (fragment(AliceAddr, BobAddr, TEST-FILE, 2, 3, 5, 1, 10, false, false) :
                                               fragment(AliceAddr, BobAddr, TEST-FILE, 2, 4, 5, 2, 10, false, false)),
                            lastFragment: true,
                            inSeqNo: 2,
                            inFragNo: 4,
                            severWResponseTTL: 10.0, severWResponseTTL: 0.0, fragmentsToSend: mtfl, numAttempts: 0),
                           (to addrWNS from cAddr : query(1, nm(fragment(AliceAddr, BobAddr, TEST-FILE, 2, 5, 5, 3, 10, false, true)) . 'pwnd2 . 'com . root, a))))  ==
  (fragmentsReceived: (fragment(AliceAddr, BobAddr, TEST-FILE, 2, 3, 5, 1, 10, false, false) :
                      fragment(AliceAddr, BobAddr, TEST-FILE, 2, 4, 5, 2, 10, false, false) :
                      fragment(AliceAddr, BobAddr, TEST-FILE, 2, 5, 5, 3, 10, false, true)),
   lastFragment: true,
   inSeqNo: 2,
   inFragNo: 5,
   severWResponseTTL: 10.0, severWResponseTTL: 0.0, fragmentsToSend: mtfl, numAttempts: 0) .
*** New fragment is a duplicate from the same packet.
red getAttributes(extractS((fragmentsReceived: (fragment(AliceAddr, BobAddr, TEST-FILE, 2, 3, 5, 1, 10, false, false) :
                                               fragment(AliceAddr, BobAddr, TEST-FILE, 2, 4, 5, 2, 10, false, false)),
                           lastFragment: false,
                           inSeqNo: 2,
                           inFragNo: 4,
                           severWResponseTTL: 10.0, severWResponseTTL: 0.0, fragmentsToSend: mtfl, numAttempts: 0),
                           (to addrWNS from cAddr : query(1, nm(fragment(AliceAddr, BobAddr, TEST-FILE, 2, 3, 5, 1, 10, false, false)) . 'pwnd2 . 'com . root, a)))) ==
  (fragmentsReceived: (fragment(AliceAddr, BobAddr, TEST-FILE, 2, 3, 5, 1, 10, false, false) :
                      fragment(AliceAddr, BobAddr, TEST-FILE, 2, 4, 5, 2, 10, false, false)),
   lastFragment: false,
   inSeqNo: 2,
   inFragNo: 4,
   severWResponseTTL: 10.0, severWResponseTTL: 0.0, fragmentsToSend: mtfl, numAttempts: 0) .
*** New fragment is a duplicate, an old fragment from a previous packet that must have gotten delayed.
red getAttributes(extractS((fragmentsReceived: (fragment(AliceAddr, BobAddr, TEST-FILE, 2, 3, 5, 1, 10, false, false) :
                                               fragment(AliceAddr, BobAddr, TEST-FILE, 2, 4, 5, 2, 10, false, false)),
                            lastFragment: false,
                            inSeqNo: 2,
                            inFragNo: 4,
                            severWResponseTTL: 10.0, severWResponseTTL: 0.0, fragmentsToSend: mtfl, numAttempts: 0),
                           (to addrWNS from cAddr : query(1, nm(fragment(AliceAddr, BobAddr, TEST-FILE, 1, 3, 4, 1, 10, false, false)) . 'pwnd2 . 'com . root, a)))) ==
  (fragmentsReceived: (fragment(AliceAddr, BobAddr, TEST-FILE, 2, 3, 5, 1, 10, false, false) :
                      fragment(AliceAddr, BobAddr, TEST-FILE, 2, 4, 5, 2, 10, false, false)),
                      lastFragment: false,
                      inSeqNo: 2,
                      inFragNo: 4,
                      severWResponseTTL: 10.0, severWResponseTTL: 0.0, fragmentsToSend: mtfl, numAttempts: 0) .
*** New fragment is from the next packet.  Clean up the previous fragments and start new.
red getAttributes(extractS((fragmentsReceived: (fragment(AliceAddr, BobAddr, TEST-FILE, 2, 3, 5, 1, 10, false, false) :
                                               fragment(AliceAddr, BobAddr, TEST-FILE, 2, 4, 5, 2, 10, false, false)),
                            lastFragment: false,
                            inSeqNo: 2,
                            inFragNo: 4,
                            severWResponseTTL: 10.0, severWResponseTTL: 0.0, fragmentsToSend: mtfl, numAttempts: 0),
                           (to addrWNS from cAddr : query(1, nm(fragment(AliceAddr, BobAddr, TEST-FILE, 3, 1, 6, 2, 10, false, false)) . 'pwnd2 . 'com . root, a)))) ==
  (fragmentsReceived: (mtfl : fragment(AliceAddr, BobAddr, TEST-FILE, 3, 1, 6, 2, 10, false, false)),
   lastFragment: false,
   inSeqNo: 3,
   inFragNo: 1,
   severWResponseTTL: 10.0, severWResponseTTL: 0.0, fragmentsToSend: mtfl, numAttempts: 0) .
*** Same as prev, but is last fragment.
red getAttributes(extractS((fragmentsReceived: (fragment(AliceAddr, BobAddr, TEST-FILE, 2, 3, 5, 1, 10, false, false) :
                                               fragment(AliceAddr, BobAddr, TEST-FILE, 2, 4, 5, 2, 10, false, false)),
                            lastFragment: true,
                            inSeqNo: 2,
                            inFragNo: 4,
                            severWResponseTTL: 10.0, severWResponseTTL: 0.0, fragmentsToSend: mtfl, numAttempts: 0),
                           (to addrWNS from cAddr : query(1, nm(fragment(AliceAddr, BobAddr, TEST-FILE, 3, 1, 6, 2, 10, false, true)) . 'pwnd2 . 'com . root, a)))) ==
  (fragmentsReceived: (mtfl : fragment(AliceAddr, BobAddr, TEST-FILE, 3, 1, 6, 2, 10, false, true)),
   lastFragment: true,
   inSeqNo: 3,
   inFragNo: 1,
   severWResponseTTL: 10.0, severWResponseTTL: 0.0, fragmentsToSend: mtfl, numAttempts: 0) .

red isTxComplete(wClientAttrs, fragmentsToSend: mtfl) == true .
red isTxComplete(wClientAttrs, fragmentsToSend: fragment(AliceAddr, BobAddr, TEST-FILE, 1, 1, 2, 3, 20, false, true)) == false .


*** Testing server response to fragments 

*** ACK a new fragment (Alice has sent fragment (2,5) and Bob has a fragment (5,4) to send to Alice)
red getMsg(extractS((fragmentsToSend: (fragment(BobAddr, AliceAddr, file(1000), 5, 4, 0, 0, 10, false, false): fragment(BobAddr, AliceAddr, file(1000), 5, 5, 0, 0, 10, false, true)), fragmentsReceived: (fragment(AliceAddr, BobAddr, file(500), 2, 3, 5, 1, 10, false, false) : fragment(AliceAddr, BobAddr, file(500), 2, 4, 5, 2, 10, false, false)), lastFragment: true, inSeqNo: 2, inFragNo: 4, severWResponseTTL: 0.0, numAttempts: 0),
  (to addrWNS from cAddr : query(1, nm(fragment(AliceAddr, BobAddr, file(500), 2, 5, 5, 3, 10, false, true)) . 'pwnd2 . 'com . root, a)))) ==
(to cAddr from addrWNS : response(1, nm(fragment(AliceAddr, BobAddr, file(500), 2, 5, 5, 3, 10, false, true)) . 'pwnd2 . 'com . root, < nm(fragment(AliceAddr, BobAddr, file(500), 2, 5, 5, 3, 10, false, true)) . 'pwnd2 . 'com . root, a, 0.0, nm(fragment(BobAddr, AliceAddr, file(1000), 5, 4, 2, 5, 10, false, false))>, nil, nil, 0)) .

*** ACK a new fragment (Alice has sent fragment (2,5) and Bob has no fragments left to send)
red getMsg(extractS((fragmentsToSend: mtfl, fragmentsReceived: (fragment(AliceAddr, BobAddr, file(1000), 2, 3, 5, 1, 10, false, false) : fragment(AliceAddr, BobAddr, file(1000), 2, 4, 5, 2, 10, false, false)), lastFragment: true, inSeqNo: 2, inFragNo: 4, severWResponseTTL: 0.0, numAttempts: 0),
  (to addrWNS from cAddr : query(1, nm(fragment(AliceAddr, BobAddr, file(1000), 2, 5, 5, 3, 10, false, true)) . 'pwnd2 . 'com . root, a)))) ==
(to cAddr from addrWNS : response(1, nm(fragment(AliceAddr, BobAddr, file(1000), 2, 5, 5, 3, 10, false, true)) . 'pwnd2 . 'com . root, < nm(fragment(AliceAddr, BobAddr, file(1000), 2, 5, 5, 3, 10, false, true)) . 'pwnd2 . 'com . root, a, 0.0, nm(fragment(BobAddr, AliceAddr, file(0), 0, 0, 2, 5, 0, false, false))>, nil, nil, 0)) .

*** incoming fragment has already been received (still send a downstream fragment but ACK the latest fragment from Alice)
red getMsg(extractS((fragmentsToSend: (fragment(BobAddr, AliceAddr, file(1000), 5, 4, 0, 0, 10, false, false): fragment(BobAddr, AliceAddr, file(1000), 5, 5, 0, 0, 10, false, true)), fragmentsReceived: (fragment(AliceAddr, BobAddr, file(500), 2, 3, 5, 1, 10, false, false) : fragment(AliceAddr, BobAddr, file(500), 2, 4, 5, 2, 10, false, false)), lastFragment: true, inSeqNo: 2, inFragNo: 4, severWResponseTTL: 0.0, numAttempts: 0),
  (to addrWNS from cAddr : query(1, nm(fragment(AliceAddr, BobAddr, file(500), 2, 3, 5, 3, 10, false, true)) . 'pwnd2 . 'com . root, a)))) ==
(to cAddr from addrWNS : response(1, nm(fragment(AliceAddr, BobAddr, file(500), 2, 3, 5, 3, 10, false, true)) . 'pwnd2 . 'com . root, < nm(fragment(AliceAddr, BobAddr, file(500), 2, 3, 5, 3, 10, false, true)) . 'pwnd2 . 'com . root, a, 0.0, nm(fragment(BobAddr, AliceAddr, file(1000), 5, 4, 2, 4, 10, false, false))>, nil, nil, 0)) .

*** ACK a new fragment (Alice has sent fragment (2,5) and Bob has no fragments left to send)
red getMsg(extractS((fragmentsToSend: mtfl, fragmentsReceived: (fragment(AliceAddr, BobAddr, file(1000), 2, 3, 5, 1, 10, false, false) : fragment(AliceAddr, BobAddr, file(1000), 2, 4, 5, 2, 10, false, false)), lastFragment: true, inSeqNo: 2, inFragNo: 4, severWResponseTTL: 0.0, numAttempts: 0),
  (to addrWNS from cAddr : query(1, nm(fragment(AliceAddr, BobAddr, file(1000), 2, 5, 5, 3, 10, false, true)) . 'pwnd2 . 'com . root, a)))) ==
(to cAddr from addrWNS : response(1, nm(fragment(AliceAddr, BobAddr, file(1000), 2, 5, 5, 3, 10, false, true)) . 'pwnd2 . 'com . root, < nm(fragment(AliceAddr, BobAddr, file(1000), 2, 5, 5, 3, 10, false, true)) . 'pwnd2 . 'com . root, a, 0.0, nm(fragment(BobAddr, AliceAddr, file(0), 0, 0, 2, 5, 0, false, false))>, nil, nil, 0)) .

*** incoming fragment has already been received (still send a downstream fragment but ACK the latest fragment from Alice)
red getMsg(extractS((fragmentsToSend: (fragment(BobAddr, AliceAddr, file(1000), 5, 4, 0, 0, 10, false, false): fragment(BobAddr, AliceAddr, file(1000), 5, 5, 0, 0, 10, false, true)), fragmentsReceived: (fragment(AliceAddr, BobAddr, file(500), 2, 3, 5, 1, 10, false, false) : fragment(AliceAddr, BobAddr, file(500), 2, 4, 5, 2, 10, false, false)), lastFragment: true, inSeqNo: 2, inFragNo: 4, severWResponseTTL: 0.0, numAttempts: 0),
  (to addrWNS from cAddr : query(1, nm(fragment(AliceAddr, BobAddr, file(500), 2, 3, 5, 3, 10, false, true)) . 'pwnd2 . 'com . root, a)))) ==
(to cAddr from addrWNS : response(1, nm(fragment(AliceAddr, BobAddr, file(500), 2, 3, 5, 3, 10, false, true)) . 'pwnd2 . 'com . root, < nm(fragment(AliceAddr, BobAddr, file(500), 2, 3, 5, 3, 10, false, true)) . 'pwnd2 . 'com . root, a, 0.0, nm(fragment(BobAddr, AliceAddr, file(1000), 5, 4, 2, 4, 10, false, false))>, nil, nil, 0)) .

*** ACK a new fragment (Alice has sent fragment (2,5) and Bob has no fragments left to send)
red getMsg(extractS((fragmentsToSend: mtfl, fragmentsReceived: (fragment(AliceAddr, BobAddr, file(1000), 2, 3, 5, 1, 10, false, false) : fragment(AliceAddr, BobAddr, file(1000), 2, 4, 5, 2, 10, false, false)), lastFragment: true, inSeqNo: 2, inFragNo: 4, severWResponseTTL: 0.0, numAttempts: 0),
  (to addrWNS from cAddr : query(1, nm(fragment(AliceAddr, BobAddr, file(1000), 2, 5, 5, 3, 10, false, true)) . 'pwnd2 . 'com . root, a)))) ==
(to cAddr from addrWNS : response(1, nm(fragment(AliceAddr, BobAddr, file(1000), 2, 5, 5, 3, 10, false, true)) . 'pwnd2 . 'com . root, < nm(fragment(AliceAddr, BobAddr, file(1000), 2, 5, 5, 3, 10, false, true)) . 'pwnd2 . 'com . root, a, 0.0, nm(fragment(BobAddr, AliceAddr, file(0), 0, 0, 2, 5, 0, false, false))>, nil, nil, 0)) .

*** incoming fragment has already been received (still send a downstream fragment but ACK the latest fragment from Alice)
red getMsg(extractS((fragmentsToSend: (fragment(BobAddr, AliceAddr, file(1000), 5, 4, 0, 0, 10, false, false): fragment(BobAddr, AliceAddr, file(1000), 5, 5, 0, 0, 10, false, true)), fragmentsReceived: (fragment(AliceAddr, BobAddr, file(500), 2, 3, 5, 1, 10, false, false) : fragment(AliceAddr, BobAddr, file(500), 2, 4, 5, 2, 10, false, false)), lastFragment: true, inSeqNo: 2, inFragNo: 4, severWResponseTTL: 0.0, numAttempts: 0),
  (to addrWNS from cAddr : query(1, nm(fragment(AliceAddr, BobAddr, file(500), 2, 3, 5, 3, 10, false, true)) . 'pwnd2 . 'com . root, a)))) ==
(to cAddr from addrWNS : response(1, nm(fragment(AliceAddr, BobAddr, file(500), 2, 3, 5, 3, 10, false, true)) . 'pwnd2 . 'com . root, < nm(fragment(AliceAddr, BobAddr, file(500), 2, 3, 5, 3, 10, false, true)) . 'pwnd2 . 'com . root, a, 0.0, nm(fragment(BobAddr, AliceAddr, file(1000), 5, 4, 2, 4, 10, false, false))>, nil, nil, 0)) .

*** incoming fragment is from an older packet (still send a downstream fragment but ACK the latest fragment from Alice)
red getMsg(extractS((fragmentsToSend: (fragment(BobAddr, AliceAddr, file(1000), 5, 4, 0, 0, 10, false, false): fragment(BobAddr, AliceAddr, file(1000), 5, 5, 0, 0, 10, false, true)), fragmentsReceived: (fragment(AliceAddr, BobAddr, file(500), 2, 3, 5, 1, 10, false, false) : fragment(AliceAddr, BobAddr, file(500), 2, 4, 5, 2, 10, false, false)), lastFragment: true, inSeqNo: 2, inFragNo: 4, severWResponseTTL: 0.0, numAttempts: 0),
  (to addrWNS from cAddr : query(1, nm(fragment(AliceAddr, BobAddr, file(750), 1, 3, 5, 3, 10, false, true)) . 'pwnd2 . 'com . root, a)))) ==
(to cAddr from addrWNS : response(1, nm(fragment(AliceAddr, BobAddr, file(750), 1, 3, 5, 3, 10, false, true)) . 'pwnd2 . 'com . root, < nm(fragment(AliceAddr, BobAddr, file(750), 1, 3, 5, 3, 10, false, true)) . 'pwnd2 . 'com . root, a, 0.0, nm(fragment(BobAddr, AliceAddr, file(1000), 5, 4, 2, 4, 10, false, false))>, nil, nil, 0)) .

*** incoming fragment is a new packet (sequence number bigger)
red getMsg(extractS((fragmentsToSend: (fragment(BobAddr, AliceAddr, file(1000), 5, 4, 0, 0, 10, false, false): fragment(BobAddr, AliceAddr, file(1000), 5, 5, 0, 0, 10, false, true)), fragmentsReceived: (fragment(AliceAddr, BobAddr, file(500), 2, 3, 5, 1, 10, false, false) : fragment(AliceAddr, BobAddr, file(500), 2, 4, 5, 2, 10, false, false)), lastFragment: true, inSeqNo: 2, inFragNo: 4, severWResponseTTL: 0.0, numAttempts: 0),
  (to addrWNS from cAddr : query(1, nm(fragment(AliceAddr, BobAddr, file(750), 3, 3, 5, 3, 10, false, true)) . 'pwnd2 . 'com . root, a)))) ==
(to cAddr from addrWNS : response(1, nm(fragment(AliceAddr, BobAddr, file(750), 3, 3, 5, 3, 10, false, true)) . 'pwnd2 . 'com . root, < nm(fragment(AliceAddr, BobAddr, file(750), 3, 3, 5, 3, 10, false, true)) . 'pwnd2 . 'com . root, a, 0.0, nm(fragment(BobAddr, AliceAddr, file(1000), 5, 4, 3, 3, 10, false, false))>, nil, nil, 0)) .

*** Testing client response to downstream fragments
red extract(
(fragmentsReceived: (fragment(BobAddr, AliceAddr, file(1000), 2, 3, 5, 1, 10, false, false) : fragment(BobAddr, AliceAddr, file(1000), 2, 4, 5, 2, 10, false, false)), 
        lastFragment: false, inSeqNo: 2, inFragNo: 4, severWResponseTTL: 0.0, fragmentsToSend: mtfl), 
      response(1, nm(fragment(AliceAddr, BobAddr, file(500), 5, 3, 2, 4, 10, false, true)) . 'pwnd2 . 'com . root, < nm(fragment(AliceAddr, BobAddr, file(500), 5, 3, 2, 4, 10, false, true)) . 'pwnd2 . 'com . root, a, 0.0, nm(fragment(BobAddr, AliceAddr, file(1000), 2, 5, 5, 3, 10, false, false)) >, nil, nil, 0))
 ==
  (fragmentsReceived: (fragment(BobAddr, AliceAddr, file(1000), 2, 3, 5, 1, 10, false, false) : fragment(BobAddr, AliceAddr, file(1000), 2, 4, 5, 2, 10, false, false) : fragment(BobAddr, AliceAddr, file(1000), 2, 5, 5, 3, 10, false, false)), 
        lastFragment: false, inSeqNo: 2, inFragNo: 5, severWResponseTTL: 0.0, fragmentsToSend: mtfl) .

*** Testing client response when it is waiting for an ACK--if ACK from Bob matches expected ACK, Alice moves up fragment and updates fragment counter
red extract(
(fragmentsReceived: (fragment(BobAddr, AliceAddr, file(1000), 2, 3, 5, 1, 10, false, false) : fragment(BobAddr, AliceAddr, file(1000), 2, 4, 5, 2, 10, false, false)), 
        lastFragment: false, inSeqNo: 2, inFragNo: 4, outSeqNo: 5, outFragNo: 3, severWResponseTTL: 0.0, fragmentsToSend: (fragment(AliceAddr, BobAddr, file(500), 5, 3, 0, 0, 10, false, false)), numAttempts: 2), 
      response(1, nm(fragment(AliceAddr, BobAddr, file(500), 5, 3, 2, 4, 10, false, true)) . 'pwnd2 . 'com . root, < nm(fragment(AliceAddr, BobAddr, file(500), 5, 3, 2, 4, 10, false, true)) . 'pwnd2 . 'com . root, a, 0.0, nm(fragment(BobAddr, AliceAddr, file(1000), 2, 5, 5, 3, 10, false, false)) >, nil, nil, 0))
 ==
  (fragmentsReceived: (fragment(BobAddr, AliceAddr, file(1000), 2, 3, 5, 1, 10, false, false) : fragment(BobAddr, AliceAddr, file(1000), 2, 4, 5, 2, 10, false, false) : fragment(BobAddr, AliceAddr, file(1000), 2, 5, 5, 3, 10, false, false)), 
        lastFragment: false, inSeqNo: 2, inFragNo: 5, outSeqNo: 5, outFragNo: 4, severWResponseTTL: 0.0, fragmentsToSend: mtfl, numAttempts: 0) .


