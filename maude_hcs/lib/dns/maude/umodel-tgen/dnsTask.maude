set show advisories off .


load user-model-aux.maude


-------------------------------------------------------
---- DNSTask Actor 
-------------------------------------------------------
***(
A task actor, addr, accepts message (to addr from umAddr :
task("query")) carries out its task (possibly sending and
receiving several messages) and then sends (to mmAddr
from addr : status,T) --- T is the completion time. 
)

***( 
for namelist, idlist, query, response
)
load ../../../../deps/dns_formalization/Maude/src/common/prelim.maude


mod DNS-TASK is
  inc USER-MODEL-AUX .
  inc SCHEDULER .   ---- apmaude
  inc MY-SAMPLER .  ---- user-model-aux
  inc MSG .         ---- prelim
  
vars n j i rj l index : Nat .  
vars r : Rat .
vars params dnsParams : Params .
vars name name1 : Name .
vars namel : NameList .
vars fl T : Float .
vars addr dAddr umAddr rAddr : Address .
vars attrs attrs1 : AttributeSet .
vars recs0 recs1 recs2 : List{Record} .
vars msg msg1 : Msg .
vars qtype : RType .
vars query query1 : Query .
  
--- DNSTask params 
  
op dnsPar:_ : Params -> Attribute [ctor] .
op nameDb:_ : NameList -> Param [ctor] .
op retryTO:_ : Float -> Param  [ctor] .  
op retryMax:_ : Nat -> Param  [ctor] .

---- Other attributes
op ctr:_ : Nat -> Attribute [ctor] . --- to generate query id
op lenNDB:_ : Nat -> Attribute [ctor] .
op nRetry:_ : Nat -> Attribute [ctor] .
op w4:_ : Query -> Attribute [ctor] .
op replyTo:_ : Address -> Attribute [ctor] .  --- the MM actor
op dnsRsv:_ : Address -> Attribute [ctor] . --- resolver actor

op getNameDB : Params -> NameList .
op getRetryTO : Params -> Float .
op getRetryMax : Params -> Nat .

eq getNameDB((params, nameDb: namel)) = namel .
eq getRetryTO((params, retryTO: fl)) = fl .
eq getRetryMax((params, retryMax: n)) = n .

op len : NameList -> Nat .
op lenX : NameList Nat ->  Nat .
eq len(nilNL) = 0 .
eq len(name namel) = lenX(namel,1) .
eq lenX(name namel,n) = lenX(namel,s n) .
eq lenX(nilNL,n) = n .

op select : NameList Nat -> Name .
eq select(name namel,0) = name .
eq select(name namel,s j) = select(namel, j) .
eq select(nilNL,j) = nullName .


----- fix QType as a for now.
----- pick from nameList randomly  r in [0,1], l len(namel)
------ 0<= rnd  < 1,  0 <= rnd * l < l

----- 0 <= r < l , i <= r < l -- want max such i
op getIndex : Rat Nat -> Nat .
op getIndexX : Rat Nat Nat -> Nat .
eq getIndex(r,l) = getIndexX(r,l,0) .
eq getIndexX(r,l,i) = 
      ( if r < s i 
       then i
       else (if s i >= l
             then l
             else getIndexX(r,l,s i)
             fi)
       fi) .
    

op genQName : Params Nat Nat -> Name .
ceq genQName(params,l,rj) = 
   (if index >= l
    then nullName
    else select(namel,index)
    fi)
if namel := getNameDB(params)
/\ index :=  getIndex((random(rj) / 4294967296 ) * l,l) 
.

op noQuery : -> Query [ctor]  .
op DNSTask : -> ActorType . 
op dnsTTO : Query -> Content .
op defaultDelay : -> Float .

op mkDnsTA : Address  Address Params -> Actor .
eq mkDnsTA(addr,rAddr,params) =
 < addr : DNSTask | dnsPar: params, ctr: 0, w4: noQuery, 
                    dnsRsv: rAddr, replyTo: nullAddr, 
                    nRetry: 0, lenNDB: len(getNameDB(params))
    >  .
                      
 
crl [startDNSTask]:
randCtr(rj)
(to dAddr from umAddr : task("query"))
< dAddr : DNSTask | dnsPar: dnsParams, dnsRsv: rAddr, 
                   lenNDB: l, ctr: j, nRetry: i, w4: noQuery, 
                   replyTo: nullAddr, attrs >
=>
< dAddr : DNSTask | dnsPar: dnsParams, dnsRsv: rAddr, 
                   lenNDB: l, ctr: s j, nRetry: 0, w4: query, 
                   replyTo: umAddr, attrs >
randCtr(s s s rj)
**** [delayParamd(msg), msg, dropParamd(msg)]
[defaultDelay + genRandomX(s s j, 0.0, 0.01), msg, 0]
[getRetryTO(dnsParams) + genRandomX(s j, 0.0, 0.0001), msg1, 0]
**** [delayParamd(msg), msg, dropParamd(msg)]
if name := genQName(dnsParams,l,rj)
/\ query := query(j,name,a)
/\ msg :=  (to rAddr from dAddr : query)
/\ msg1 := (to dAddr : dnsTTO(query))

[print "DNSTask startDNSTask sends " msg]
.
  
rl[dnsResponse]:
{T, (to dAddr from rAddr :
             response(i,name,recs0,recs1,recs2,j))}
< dAddr : DNSTask | dnsRsv: rAddr, nRetry: n,
                    w4: query(i,name,qtype), 
                    replyTo: umAddr, attrs >
=>
< dAddr : DNSTask | dnsRsv: rAddr, nRetry: 0,
                    w4: noQuery, 
                    replyTo: nullAddr, attrs >
(to umAddr from dAddr : status("success",T))
[print "DNSTask dnsResponse sends success to " umAddr " at " T]
.

crl[dnsResponseRedundant]:
{T, (to dAddr from rAddr :
             response(i,name,recs0,recs1,recs2,j))}
< dAddr : DNSTask | dnsRsv: rAddr, nRetry: n,
                    w4: query,
                    replyTo: umAddr, attrs >
=>
< dAddr : DNSTask | dnsRsv: rAddr, nRetry: 0,
                    w4: query, 
                    replyTo: umAddr, attrs >
if not(eqQId(query,i))
[print "DNSTask dnsResponseRedundant: i " i " w4 " query " at " T]
.

op eqQId : Query  Id -> Bool .
eq eqQId(query(j,name,qtype),i) =  (i == j) .
eq eqQId(query,i) = false [owise] .

crl[dnsTOretry]:
randCtr(rj)
{T, (to dAddr  : dnsTTO(query))} 
< dAddr : DNSTask | dnsPar: dnsParams, dnsRsv: rAddr, 
                   nRetry: n, w4: query, attrs >
=>
< dAddr : DNSTask | dnsPar: dnsParams, dnsRsv: rAddr, 
                    nRetry: s n, w4: query, attrs >
randCtr(s s rj)
**** [delayParamd(msg), msg, dropParamd(msg)]
[defaultDelay + genRandomX(rj, 0.0, 0.01), msg, 0]
[getRetryTO(dnsParams) + genRandomX(s rj, 0.0, 0.0001), msg1, 0]
if n < getRetryMax(dnsParams)
/\ msg := (to rAddr from dAddr : query)
/\ msg1 := (to dAddr : dnsTTO(query))
[print "DNSTask dnsTOretry nRetry " n " at " T]
.

crl[dnsTOgiveup]:
{T, (to dAddr  : dnsTTO(query))} 
< dAddr : DNSTask | dnsPar: dnsParams, nRetry: n, 
                    w4: query, replyTo: umAddr, attrs >
=>
< dAddr : DNSTask | dnsPar: dnsParams, nRetry: 0, 
                    w4: noQuery, replyTo: umAddr, attrs >
(to umAddr from dAddr : status("failure",T))
if n >= getRetryMax(dnsParams)
[print "DNSTask dnsTOretry nRetry " n " send failure to " umAddr " at " T]
.

crl[dnsTOretryCancel]:
{T, (to dAddr  : dnsTTO(query))} 
< dAddr : DNSTask | dnsPar: dnsParams, dnsRsv: rAddr, 
                   nRetry: n, w4: query1, attrs >
=>
< dAddr : DNSTask | dnsPar: dnsParams, dnsRsv: rAddr, 
                    nRetry: n, w4: query1, attrs >
if query1 =/= query
[print "DNSTask dnsTOretryCancel nRetry: n " n  " w4 " query1 " TOQuery " query " at " T]
.

endm
eof

mod DNSTASK-SCENARIO is
 inc DNS-TASK .
 
 op dnsTPar : -> Params .
 
 op dnameDb : -> NameList .
 eq dnameDb = ('foo . 'com . root) ('baz . 'org . root) 
              ('bar . 'edu . root) .
 eq dnsTPar = (
     nameDb: dnameDb,
     retryTO: 5.0,
     retryMax: 2 
 )
.

op fakeRSV : -> ActorType .
vars i rj j : Nat .
vars T : Float .
vars rAddr addr : Address .
vars name : Name .
vars qtype : RType .


rl[fakeRsp]:
randCtr(rj)
{T, to rAddr from addr : query(i,name,qtype)}
< rAddr : fakeRSV | ctr: j > 
=>
< rAddr : fakeRSV | ctr: s j > 
randCtr(s rj)
[defaultDelay + genRandomX(rj, 0.0, 0.01), 
 (to addr from rAddr : response(i,name,nil,nil,nil,0)),
 0]
[print "FakeRsv at " T]
.

op mkFakeRSV : Address -> Actor .
eq mkFakeRSV(rAddr) = < rAddr : fakeRSV | ctr: 0 > .

endm


mod TEST-DNSTASK is
  inc DNSTASK-SCENARIO .
  
  eq defaultDelay = 1.5 .
  
  ops umDAddr dnsTAddr rsvAddr : -> Address .

  op dnsTA : -> Actor .
  eq dnsTA =  mkDnsTA(dnsTAddr,rsvAddr,dnsTPar) .

  op fakeRSV : -> Actor .
  eq fakeRSV = mkFakeRSV(rsvAddr) .

endm
eof

set print attribute on .
rew 
randCtr(1) dnsTA (to dnsTAddr from umDAddr : task("query")) .
 
rew  
run({0.0 | nil} randCtr(1) dnsTA (to dnsTAddr from umDAddr : task("query")), 100.0)  .
 
rew run({0.0 | [2.0 , (to dnsTAddr from rsvAddr : response(0,'baz . 'org . root, nil,nil,nil,0)),0]} randCtr(1) dnsTA (to dnsTAddr from umDAddr : task("query")), 100.0) .
 
 
red mkFakeRSV(rsvAddr) .

rew randCtr(0) fakeRSV {T, to rsvAddr from dnsTAddr : query(0,root,a)} .

rew  
run({0.0 | nil} randCtr(1) dnsTA fakeRSV (to dnsTAddr from umDAddr : task("query")), 100.0)  .



------------------------ 
***(
< dtAdder : DNSTGen | umAttrs, dnsttAttrs >
~ 
{
< umAddr : MModel |  umAttrs >
< ttAddr : DNSTask | dnsttAttrs >
}[
receptionist: umAddr~>dtAddr, ttAddr (exported)]
externals: X(rsvAddr)]

}
)
