mod SMC is

  inc IODINE_TEST .

  var AC : ActorConfig .
  var attrs : AttributeSet .

  vars PTL PTL' PTL'' PTL''' : PacketTimestampList .
  vars Pkt Pkt' : Packet .
  var C : Config .
  var id : Nat .
  vars len, len' : Nat .
  var A : Actor .
  var N : Nat .
  var last? : Bool .
  vars T T' T'' T''' : Float .
  var ADDR AppAddrFrom AppAddrTo : Address .

  var QTL QTL' : QueryTimestampList .
  var QUERY : Query .

  var TML : TimeMsgList .
  var M : Msg .
  var TH : Float .
  var GT : Float .
  var I : Int .

  var bytes : ByteSeq .

  op getMonitor : Config -> Actor .
  eq getMonitor (C < ADDR : WMonitor | attrs >) = < ADDR : WMonitor | attrs > .

  op getPktSent : Actor ->  PacketTimestampList . 
  eq getPktSent (< ADDR : WMonitor | pktSent: PTL, attrs >) = PTL . 

  op getFirstPktSentTime : Actor -> Float .
  eq getFirstPktSentTime (< ADDR : WMonitor | pktSent: (PTL ; packetTimestamp(packet(AppAddrFrom, AppAddrTo, bytes, 0, len, last?), T) ; PTL'), attrs >) = T .

  op getPktRcvd : Actor ->  PacketTimestampList . 
  eq getPktRcvd (< ADDR : WMonitor | pktRcvd: PTL, attrs >) = PTL . 

  op getLastPktRcvdTime : Actor -> Float .
  eq getLastPktRcvdTime (< ADDR : WMonitor | pktRcvd: (PTL ; packetTimestamp(packet(AppAddrFrom, AppAddrTo, bytes, id, len, true), T) ; PTL'), attrs >) = T .

  op getLatency : Actor -> Float .
  eq getLatency (< ADDR : WMonitor | pktSent: (PTL ; packetTimestamp(packet(AppAddrFrom, AppAddrTo, bytes, 0, len, last?), T) ; PTL'), pktRcvd: (PTL'' ; packetTimestamp(packet(AppAddrFrom, AppAddrTo, bytes, id, len', true), T') ; PTL'''), attrs >) = T' - T .

  op getGoodput : Actor -> Float .
  eq getGoodput (< ADDR : WMonitor | pktSent: (PTL ; packetTimestamp(packet(AppAddrFrom, AppAddrTo, bytes, 0, len, last?), T) ; PTL'), pktRcvd: (PTL'' ; packetTimestamp(packet(AppAddrFrom, AppAddrTo, bytes, id, len', true), T') ; PTL'''), attrs >) = float(8 * fileSize) / (T' - T) .

  op getPTLLen : PacketTimestampList -> Nat .
  eq getPTLLen (nilPacketTimestamp) = 0 .
  eq getPTLLen (PTL ; packetTimestamp(packet(AppAddrFrom, AppAddrTo, bytes, id, len, last?), T)) = len + getPTLLen (PTL) .

  op getThroughput : Actor -> Float .
  eq getThroughput (< ADDR : WMonitor | pktSent: (PTL ; packetTimestamp(packet(AppAddrFrom, AppAddrTo, bytes, 0, len, last?), T) ; PTL'), pktRcvd: (PTL'' ; packetTimestamp(packet(AppAddrFrom, AppAddrTo, bytes, id, len', true), T') ; PTL'''), attrs >) = float(getPTLLen((PTL'' ; packetTimestamp(packet(AppAddrFrom, AppAddrTo, bytes, id, len', true), T') ; PTL''')) * 8) / (T' - T) .

  op isDone : Config -> Bool .
  eq isDone ({ F:Float | nil } AC < ADDR : WMonitor | pktRcvd: (PTL ; packetTimestamp(packet(AppAddrFrom, AppAddrTo, bytes, id, len, true), T) ; PTL'), attrs >)
    = true   
    .
  eq isDone (C) = false [owise] .

  op isDone : Config -> Bool .
  eq isDone (A { F:Float | nil } AC < ADDR : WMonitor | pktRcvd: (PTL ; packetTimestamp(packet(AppAddrFrom, AppAddrTo, bytes, id, len, true), T) ; PTL'), attrs >)
    = true   
    .
  eq isDone (C) = false [owise] .

  op getQuerySent : Actor -> QueryTimestampList . 
  eq getQuerySent (< ADDR : WMonitor | querySent: QTL, attrs >) = QTL . 

  op length : QueryTimestampList -> Nat .
  eq length (nilQueryTimestamp) = 0 .
  eq length (QTL ; queryTimestamp(QUERY, T)) = 1 + length(QTL) .

  op length : TimeMsgList -> Nat .
  eq length (nilTML) = 0 .
  eq length (TML ; tm(T, M)) = 1 + length(TML) .

  ****(
  --- General approach for triggering adversary alarms:
  --- Time is divided into bins of width s seconds
  --- At each interval tk (every s seconds), adversary computes moving average of selected network observable over the previous m bins
  --- The initial set of m bins from t0 to tm contains TGEN-only traffic
  --- Obtained either by running scenario long enough with TGEN-only to fill initial set of m bins, or by importing m previously collected TGEN-only bins
  --- Threshold format:
  --- “Combined TGEN + HCS network observable average exceeds k * initial TGEN-only network observable average for n consecutive time intervals”
  --- “How quickly and by how much does the addition of the HCS move the TGEN-only average?”

  --- k – threshold multiplier
  --- n – number of consecutive bins
  --- s – duration of each bin/interval
  --- m – number of previous bins/intervals to compute moving average over
  )

  op lengthTimeWindow : QueryTimestampList Float Float -> Nat .
  eq lengthTimeWindow (nilQueryTimestamp, T', T'') = 0 .
  eq lengthTimeWindow (QTL ; queryTimestamp(QUERY, T), T', T'') = if T > T' and T < T'' then 1 + lengthTimeWindow(QTL, T', T'') else lengthTimeWindow(QTL, T', T'') fi .

  ---- the number of messages that occured between T' and T''
  ----                              startT endT
  op lengthTimeWindow : TimeMsgList Float Float -> Nat .
  eq lengthTimeWindow (nilTML, T', T'') = 0 .
  ***** @Minyoung: Should the below be >= instead to ensure we dont skip any messages that may have occcurred at t=T'
  eq lengthTimeWindow (TML ; tm(T, M), T', T'') = if T > T' and T < T'' then 1 + lengthTimeWindow(TML, T', T'') else lengthTimeWindow(TML, T', T'') fi .

  op getNQuerySent : Actor -> Nat .
  eq getNQuerySent (< ADDR : WMonitor | querySent: QTL, attrs >) = length(QTL) .

  op getNQueryRcvd : Actor -> Nat .
  eq getNQueryRcvd (< ADDR : WMonitor | queryRcvd: QTL, attrs >) = length(QTL) .

  op getAdversary : Config -> Actor .
  eq getAdversary (C < ADDR : Adversary | attrs >) = < ADDR : Adversary | attrs > . 

  op getNQuerySent : Actor -> Nat .
  eq getNQuerySent (< ADDR : Adversary | sent: TML, attrs >) = length(TML) .

  ----- the avg QPS in a time window of size T' starting at T
  ---                     startT window 
  op avgQPS : TimeMsgList Float Float -> Float .
  eq avgQPS (TML, T, T') = float(lengthTimeWindow(TML, T, T + T')) / T' .

  ---- the largest timestamp in the list
  op lastT : TimeMsgList -> Float .
  eq lastT (TML ; tm(T, M)) = if T > lastT(TML) then T else lastT(TML) fi .
  eq lastT (nilTML) = 0.0 .

  ----- the QPS in window [T, T+T'] > th*(QPS in window [0, T'])
                        --- startT window threshold
  op highQPS : TimeMsgList Float Float Float -> Bool .
  ***** @Minyoung: do we need to check that T > T'-bin?
  eq highQPS (TML, T, T', TH) = if avgQPS (TML, T,  T') > avgQPS (TML, 0.0, T') * TH then true else false fi .
  ***** @Minyoung: does this need an owise?
  eq highQPS (nilTML, T, T', TH) = false . 

  ---- Aggregate average query rate exceeds k × initial average query rate for n consecutive time bins of width s
  ---- More clearly, we check avgQPS over n consecutive windows each of size T', shifted by bin size T'' 
  ----                   startT window/m bin/s th/k consecutive/n
  op alarm : TimeMsgList Float Float Float Float Int -> Bool .
  ceq alarm (TML, T, T', T'', TH, I) = 
      if highQPS(TML, T + (float(I) * T''), T', TH) 
      then alarm(TML, T, T', T'', TH, I - 1) 
      else false 
      fi 
    if I > 0 .
  **** @Minyoung: should this owise be split into two equations instead
  **** eq alarm (TML, T, T', T'', TH, 0) = true .
  **** eq alarm (TML, T, T', T'', TH, I) = false [owise].
  *****  would be really helpful to create some test cases for this !!
  eq alarm (TML, T, T', T'', TH, I) = true [owise].

  ***** @Minyoung: tod below is not how I expected it; I was expecting tod to be time we first got an alarm?
  *****             i.e. do we need the experiment to keep going or should isDone be true at that point?
  ----                 startT window/m bin/s th/k consecutive/n
  op tod : TimeMsgList Float Float Float Float Int -> Float .
  ceq tod (TML, T, T', T'', TH, I) = 
            (if alarm(TML, T, T', T'', TH, I) 
              then T + T' + (float(I) * T'') 
              else tod(TML, T + T'', T', T'', TH, I) 
            fi) 
            if lastT(TML) > T + T' + (float(I - 1) * T'') . 

  op getInitialQPS : Config Float -> Float .
  eq getInitialQPS (C < ADDR : Adversary | sent: TML, attrs >, T) = avgQPS (TML, 0.0, T) .  

  op getAvgQPS : Config Float Float -> Float .
  eq getAvgQPS (C < ADDR : Adversary | sent: TML, attrs >, T, T') = avgQPS (TML, T, T') .  

  op getHcsQPS : Config Float -> Float .
  eq getHcsQPS (C < ADDR : Adversary | sent: TML, attrs >, T) = avgQPS(TML, T, lastT(TML) - T) .  

                        --- init start window bin th consecutive
  op getToD : Config Float Float Float Float Int -> Float .
  eq getToD (C < ADDR : Adversary | sent: TML, attrs >, T'', T, T', TH, I) = tod(TML, T'' - T, T, T', TH, I) . 

                        --- init start window bin th consecutive
  op isDetected : Config Float Float Float Float Int -> Bool .
  eq isDetected (C < ADDR : Adversary | sent: TML, attrs >, T'', T, T', TH, I) = if tod(TML, T'' - T, T, T', TH, I) > 0.0 then true else false fi . 

  var ID : Id .
  var NAME : Name .
  var RTYPE : RType .
  vars B1 B2 : Bool .
  vars ALICE BOB : Address .
  vars N1 N2 N3 : Nat .

  op size : Name -> Nat .
  eq size (nm(fragment(ALICE, BOB, bytes, N1, N2, N3, B1, B2)) . NAME) = N3 + nameLength(NAME) .
  eq size (NAME) = nameLength(NAME) [owise] .

  op size : Query -> Nat .
  eq size (query(ID, NAME, RTYPE)) = size(NAME) .

  op size : TimeMsgList -> Nat .
  eq size (nilTML) = 0 .
  eq size (TML ; tm(T, M)) = size(getQuery(M)) + size(TML) .

  op sizeTimeWindow : TimeMsgList Float Float -> Nat .
  eq sizeTimeWindow (nilTML, T', T'') = 0 .
  eq sizeTimeWindow (TML ; tm(T, M), T', T'') = if T > T' and T < T'' then size(getQuery(M)) + sizeTimeWindow(TML, T', T'') else sizeTimeWindow(TML, T', T'') fi .

                            --- start window 
  op avgQuerySize : TimeMsgList Float Float -> Float .
  eq avgQuerySize (TML, T, T') = float(sizeTimeWindow(TML, T, T + T')) / float(lengthTimeWindow(TML, T, T + T')) .

  op getAvgQuerySize : Config -> Float .
  eq getAvgQuerySize (C < ADDR : Adversary | sent: TML, attrs >) = float(size(TML)) / float(length(TML)) .

  op getHcsQuerySize : Config Float -> Float .
  eq getHcsQuerySize (C < ADDR : Adversary | sent: TML, attrs >, T) = avgQuerySize(TML, T, lastT(TML) - T) .  

endm
