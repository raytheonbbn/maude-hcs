load ../../../deps/dns_formalization/Maude/src/nondet-model/_aux

mod MYLISTS is
  pr AUX .

  ---- Lists of messages (sent or received by apps)
  sort MsgList .  
  subsort Msg < MsgList .

  var msg : Msg .
  var msgL : MsgList .
  
  op nilMsgList : -> MsgList [ctor] .
  op _;_ : MsgList MsgList -> MsgList [ctor assoc id: nilMsgList] .

  op length : MsgList -> Nat .
  eq length(nilMsgList) = 0 .
  eq length(msg ; msgL) = s length(msgL) .
  
  ---- Alice sends "UDP packets" to the TUN IFace
  ---- Each packet has a data len (application bytes being sent), and an id for tracking
  ---- The len determines how many "fragments" are needed to send the packet over DNS
  ---- A packet gets fragmented into 1 or more fragments
  ---- A fragment is what gets embedded into a DNS query
  ----   recall subsort Nat < Id 
  
  sorts Packet Fragment .
  sorts PacketList FragmentList .
  subsort Fragment < FragmentList .
  subsort Packet < PacketList .

  var FL : FragmentList .
  var F : Fragment .
  var PL : PacketList .
  var P : Packet .

  op nilFragment : -> Fragment .
  op nilPacket : -> Packet .

  op mtfl    : -> FragmentList [ctor] .
  op mtpl    : -> PacketList [ctor] .
  op _:_    : FragmentList FragmentList -> FragmentList [ctor assoc id: mtfl] .
  op _;_    : PacketList PacketList -> PacketList [ctor assoc id: mtpl] .

  op length : FragmentList -> Nat .     
  
  eq length(mtfl) = 0 .
  eq length(F : FL) = s length(FL) .

  op popFront : FragmentList -> FragmentList .
  eq popFront(F : FL) = FL .
  eq popFront(mtfl) = mtfl .

  op peekFront : FragmentList -> Fragment .
  eq peekFront(F : FL) = F .
  eq peekFront(mtfl) = nilFragment .

endm

--- view FragmentList from TRIV to MYLISTS is
---   sort Elt to FragmentList .
--- endv

--- view PacketList from TRIV to MYLISTS is
---   sort Elt to PacketList .
--- endv

mod IODINE_SORTS is   
  pr MYLISTS .
---  inc META-LEVEL .
---  pr CONVERSION .
  
  vars ALICE BOB : Address . 
  var NAME : Name .
  vars N N1 N2 N3 P_LEN : Nat .
  var B B1 : Bool .  
 

  subsorts Packet Fragment < Content . 
  ----        AliceAddr Packet# DataLenBytes  
  op packet : Address Nat Nat -> Packet .
  ----          AliceAddr  Packet# Frag# DataLenBytes lastFrag
  op fragment : Address Nat Nat Nat Bool -> Fragment .  
  --- convert a fragment into a Name to be embedded
  op nm : Fragment -> Name .  
  --- convert back to fragment
  op fragment : Name -> Fragment .    

  --- convert a fragment into a Qid to be embedded
  --- op toQId : Fragment -> Qid .
  --- op toQId : Qid Nat Nat Nat -> Qid .
  --- eq toQId(fragment(QID1, N, N1, N2)) = toQId(QID1, N, N1, N2) .
  --- eq toQId(QID1, N, N1, N2) = qid(string(QID1) + "#" + string(N,10) + "#" + string(N1, 10) + "#" + string(N2, 10)) .
  
  eq fragment(nm(fragment(ALICE, N, N1, N2, B))) = fragment(ALICE, N, N1, N2, B) .
  eq fragment(NAME) = nilFragment [owise] .

  op isLastFragment : Fragment -> Bool .
  eq isLastFragment(fragment(ALICE, N, N1, N2, B)) = B .

  op getPacketLength : Packet -> Nat .
  eq getPacketLength(packet(ALICE, N, P_LEN)) = P_LEN .


endm  
--- these views allow us to create lists LIST{X} where X is sort Packet or Fragment
--- view Packet from TRIV to IODINE_SORTS is sort Elt to Packet . endv
--- view Fragment from TRIV to IODINE_SORTS is sort Elt to Fragment . endv



mod IODINE_AUX is
  pr IODINE_SORTS .
  --- pr LIST{Packet} .
---  pr LIST{Fragment} .
  
  sorts MapIdMsg  IdMsg .
  subsort IdMsg < MapIdMsg .
  
  vars N N1 N2 N3 P_LEN : Nat .
  var B B1 LAST_FRAG : Bool .
  ---var curFragments : List{Fragment} .
  var curFragments : FragmentList .
  var Pkt Pkt1 : Packet .
  var Frag Frag1 : Fragment .
  var ALICE : Address .

  var wdb : MapIdMsg .
  var ID : Id .
  var msg msg0 : Msg .

  ---- Used by iodine server when extracting information from Query
  sort AttributeSetMsgs .
  sort AttributeSetPair .
  ----              serverAttrs Msgs
  op `{_`,_`} : AttributeSet Config -> AttributeSetMsgs [ctor] .  
  ----              serverAttrs appAttrs
  op `{_`,_`} : AttributeSet AttributeSet -> AttributeSetPair [ctor] .

  op _<~_ : Id Msg -> IdMsg [ctor] .
  op mtIdMsg : -> MapIdMsg .
  op  _!!_ : MapIdMsg MapIdMsg -> MapIdMsg 
                 [ctor assoc comm id: mtIdMsg] .
  op updateMap : MapIdMsg Id Msg -> MapIdMsg .
  eq updateMap(wdb !! (ID <~ msg0), ID, msg) 
          = wdb !! (ID <~ msg) .
  eq updateMap(wdb,ID,msg) = wdb !! (ID <~ msg) [owise] .

  ----        return list of fragments that form a packet
  ----          Packet HOSTNAME_LEN
  op makeFragments : Packet Nat -> FragmentList .
  ----          Packet HOSTNAME_LEN cur_frag_num cur_fragments
  op $makeFragments : Packet Nat Nat FragmentList -> FragmentList .

  ----        return packet from list of fragments 
  op makePacket : FragmentList ->  Packet .
  op $makePacket : FragmentList Packet ->  Packet .

  
  eq makeFragments(packet(ALICE, N, N1), N2) = 
    $makeFragments(packet(ALICE, N, N1), N2, 0, mtfl) .
  
  eq $makeFragments(packet(ALICE, N, N1), N2,  N3, curFragments) =
    if N1 > N2 
    then
      $makeFragments(packet(ALICE, N, (N1 - N2)), N2, s N3, curFragments : fragment(ALICE, N, s N3, N2, false)) 
    else 
      curFragments : fragment(ALICE, N, s N3, N2, true)
    fi  
    .

  eq makePacket(fragment(ALICE, N, N1, N2, B) : curFragments) = 
    $makePacket(curFragments, packet(ALICE, N, N2))  .
  eq $makePacket((fragment(ALICE, N, N1, N2, B) : curFragments), packet(ALICE, N, N3)) =
    $makePacket(curFragments, packet(ALICE, N, (N3 + N2))) .
  eq $makePacket(mtfl, Pkt) = Pkt .

endm

mod IODINE_NODE is
  inc IODINE_AUX .

  var wattrs wattrsNext wattrsTrans Attrs AttrsTrans Attrs1 Attrs2 Attrs3 : AttributeSet .
  vars CONF CONF1 : Config .
  var msg msgIn msgOut : Msg .
  var NAME NAME1 : Name .
  var F : Fragment .
  var ADDR ADDR1 AliceAddr BobAddr RESOLVER : Address .
  var ID : Id .
  var QTYPE : RType .
  vars NUM_ATTEMPTS NUM_FRAGS : Nat .
  var B LAST : Bool .
  vars SEQ_CTR QUERY_CTR CUR_FRAG : Nat .
  vars N P_LEN HOSTNAME_LEN : Nat .
  var FRAGMENT_LIST : FragmentList .
  var PACKET_LIST : PacketList .
  var db wDb : List{Record} .
  var QUERY : Query .

--------  Nesting/Meta configuration  attribute
  op conf:_ : Config -> Attribute [ctor] .
  
  --------------------------------
  --- [App Bob] --- 
  ---   Bob receives weird messages from WNameserver
  --------------------------------
  op RcvApp : -> ActorType [ctor] .
  op rcvd:_ : PacketList  -> Attribute [ctor] .

  **** constructor for making receiver app actor
  op mkRcvApp : Address  -> Actor [ctor] .  
  eq mkRcvApp(BobAddr) =
    < BobAddr : RcvApp | rcvd: mtpl > .  

  ----------------
  --- [WCLIENT] ---  Client wrapper  -- alternate view
**** wclient = < clId : WDNSClient | wattrs 
****              conf: (< appId : WApp | attrs >  msgs) ?
**** contains app used by Alice to generate hidden msgs
----------------
  op WCL : -> ActorType [ctor] .

  --- the DNS resolver - should be know to weird client
  op resv:_ : Address -> Attribute [ctor] . 
  --- the base weird name to which hidden msg is attached
  op wDom:_ : Name -> Attribute [ctor] .
  --- store info about query  sent, pending response  
  op wDb:_ : MapIdMsg -> Attribute [ctor] .
  --- increment counter for each DNS query sent
  op queryCtr:_ : Nat -> Attribute [ctor] .
  --- increment counter for each packet being sent
  op seqCtr:_ : Nat -> Attribute [ctor] .
  --- increment counter for each packet fragment being sent
  op fragmentCtr:_ : Nat -> Attribute [ctor] .
  --- fragment list, its size, and the current fragment being sent
  op fragments:_ : FragmentList -> Attribute [ctor] .  
  op fragmentsSize:_ : Nat -> Attribute [ctor] .
  op currFragment:_ : Nat -> Attribute [ctor] .
  --- number of retransmissions of current fragment
  op numAttempts:_ : Nat -> Attribute [ctor] . 

  op getResolver : AttributeSet ~> Address .
  eq getResolver(wattrs, resv: ADDR) = ADDR .

  op getWDom : AttributeSet Address ~> Name .
  eq getWDom((wattrs, wDom: NAME), ADDR) = NAME .

  op isSending : AttributeSet -> Bool .
  eq isSending(wattrs, fragmentsSize: NUM_FRAGS) =
    if NUM_FRAGS > 1
      then true 
    else
      false
    fi
    .
  eq isSending(wattrs) = false [owise] .

  --- Increment the query id.
  --- Iodine increments queries by 7727.
  op incrQueryCtr : AttributeSet -> AttributeSet .
  eq incrQueryCtr(wattrs, queryCtr: QUERY_CTR) = wattrs, (queryCtr: (QUERY_CTR + 7727)) .
  eq incrQueryCtr(wattrs) = wattrs [owise] .

  --- Get the query id.
  op getQueryCtr : AttributeSet -> Nat .
  eq getQueryCtr(wattrs, queryCtr: QUERY_CTR) = QUERY_CTR .
  eq getQueryCtr(wattrs) = wattrs [owise] .

  --- Handle a new packet (from Alice) (and bail on an old one).
  ---                   wClient Attributes Packet Max hostname length
  op handleNewPacket : AttributeSet Packet Nat -> AttributeSet .
  ceq handleNewPacket((wattrs, seqCtr: SEQ_CTR), packet(ADDR, N, P_LEN), HOSTNAME_LEN) =
    wattrs, (seqCtr: s SEQ_CTR), (currFragment: 0), (numAttempts: 0), (fragments: FRAGMENT_LIST), (fragmentsSize: length(FRAGMENT_LIST)), (fragmentCtr: 0)
      if FRAGMENT_LIST := makeFragments(packet(ADDR, N, P_LEN), HOSTNAME_LEN) . 
  eq handleNewPacket(wattrs) = wattrs [owise] .

  --- Move a fragment forward.
  op moveFragmentUp : AttributeSet -> AttributeSet .
  eq moveFragmentUp(wattrs, fragments: FRAGMENT_LIST, currFragment: CUR_FRAG) =
    wattrs, numAttempts: 0, fragments: popFront(FRAGMENT_LIST), currFragment: s CUR_FRAG .

  --- Grab a fragment to send.
  op grabCurrentFragment : AttributeSet -> Fragment .
  eq grabCurrentFragment(wattrs, fragments: FRAGMENT_LIST) = peekFront(FRAGMENT_LIST) .

---  crl [iClientEmbedding]:
---    < CL : WCL | wattrs, conf : (appA (to ADDR' from CL : wc(wmsg) msgs) >
---
---    => < CL : WCL | wattrs0, conf : (appA msgs) >
---    msg
---    if {wattrs0, msg} := embed(CL, wattrs, (to ADDR' from CL : wc(wmsg)))
---    [print "iClientEmbedding msg "  msg]
------     will require handling a new packet (via msg).
---    .

---  op handleAndSend: AttributeSet Msg -> AttributeSetAndMsgs .
---  ceq handleAndSend((wattrs resv), (to ADDR' from AliceAddr : msg)) =
---    {wattrsNext, (to resv from CL : QUERY)}
---    if PACKET := getPacket()
---      /\ wattrsTrans := handleNewPacket(wattrs, PACKET, HOSTNAME_LEN) --- Not clear how one gets HOSTNAME_LEN
---      /\ wattrsTrans := incrQueryCtr(wattrsTrans)  --- I doubt we can keep the same name
---      /\ DOMAIN_NAME := getWDom(wattrsTrans, ADDR')
---      /\ QUERY := makeQuery(DOMAIN_NAME, getQueryCtr(wattrsTrans)))
---    .

  --------------------------------
  --- [WNameserver] --- Weird/wrapped Nameserver
  --------------------------------
  op WNameserver : -> ActorType [ctor] .  
  --- This is Bob's address; weird msgs will be forwarded to bob
  --- Bob listens on a UDP socket that the server sends to
  --- Alice's address will be in the query name
  op appAddr:_ : Address -> Attribute  [ctor] .
  --- List of fragments currently being processed
  op pendingFragments:_ : FragmentList -> Attribute [ctor] .
  op lastFragment:_ : Bool -> Attribute [ctor] .


  --- op qRcd:_ : Config ->  Attribute [ctor] .  --- msgConf
       --- query msg pending response

  **** constructor for making a name server
  op mkNameServer : Address List{Record}  -> Actor [ctor] .  
  eq mkNameServer(ADDR, db) =
    < ADDR : Nameserver |
      db: db,
      queue: nilQueue,
      forwardonly: nullAddr,
      queriesFwd: nilTAQL >  .

  op isWeird : AttributeSet Msg -> Bool .
  ceq isWeird(wattrs, msg) = true
    if (to ADDR from  ADDR1 : query(ID, NAME, QTYPE)) := msg
    /\ nm(F) . NAME1 := NAME
    .
  eq isWeird(wattrs, msg) = false [owise] .

  ---- Server extract fragment
  op extractS : AttributeSet Msg -> AttributeSetMsgs .
  ceq extractS(wattrs, (to ADDR from ADDR1 : query(ID, NAME, QTYPE))) = {wattrsTrans, msgOut}
    if  nm(F) . NAME1 := NAME
    /\ (appAddr: BobAddr, pendingFragments: FRAGMENT_LIST, lastFragment: B, Attrs) := wattrs
    /\ wattrsTrans := (appAddr: BobAddr, pendingFragments: (FRAGMENT_LIST : F), lastFragment: isLastFragment(F), Attrs)
    ---- simply ACK fragment (NAME contains fragment; RCODE 0 is success)
    /\ msgOut := (to ADDR1 from ADDR : response(ID, NAME, nil, nil, nil, 0)) 
    .

  op updateRcvApp : AttributeSet AttributeSet -> AttributeSetPair .
  ceq updateRcvApp(wattrs, Attrs) = {wattrsTrans, AttrsTrans}
    ---- server attrs
    if (appAddr: BobAddr, pendingFragments: FRAGMENT_LIST, lastFragment: B, Attrs1) := wattrs
    ---- app attrs
    /\ (rcvd: PACKET_LIST, Attrs2) := Attrs
    ---- if ready to defragment clean up state else no change
    /\ wattrsTrans := 
      (if B 
      then (appAddr: BobAddr, pendingFragments: mtfl, lastFragment: false, Attrs1)
      else wattrs 
      fi)
    ---- defragment and update Bob's received packets?
    /\ AttrsTrans := 
      (if B
      then (rcvd: (PACKET_LIST ; makePacket(FRAGMENT_LIST)), Attrs2)
      else (rcvd: PACKET_LIST, Attrs2)
      fi)
      .

endm


mod PACKET_FRAGMENT_TEST is
  inc IODINE_NODE .

  ops AliceAddr BobAddr addrWNS cAddr : -> Address . 

  op wClientAttrs : -> AttributeSet .
endm

---set trace on .
set print attribute on .
  
red nm(fragment(AliceAddr, 1, 1, 100, true)) . 'microsoft . 'com . root .
red fragment(nm(fragment(AliceAddr, 1, 1, 100, true))) ==  fragment(AliceAddr, 1, 1, 100, true) .
red fragment(label(1)) == nilFragment .

red makeFragments(packet(AliceAddr, 1, 100), 10) ==
  fragment(AliceAddr, 1, 1, 10, false) : fragment(AliceAddr, 1, 2, 10, false) : fragment(AliceAddr, 1, 3, 10, false) : fragment(AliceAddr, 1, 4, 10, false) : fragment(AliceAddr, 1, 5, 10, false) : fragment(AliceAddr, 1, 6, 10, false) : fragment(AliceAddr, 1, 7, 10, false)
    : fragment(AliceAddr, 1, 8, 10, false) : fragment(AliceAddr, 1, 9, 10, false) : fragment(AliceAddr, 1, 10, 10, true)
    .
red makePacket(fragment(AliceAddr, 1, 1, 10, false) : fragment(AliceAddr, 1, 2, 10, false) : fragment(AliceAddr, 1, 3, 10, false) : fragment(AliceAddr, 1, 4, 10, false) : fragment(AliceAddr, 1, 5, 10, false) : fragment(AliceAddr, 1, 6, 10, false) : fragment(AliceAddr, 1, 7, 10, false)
    : fragment(AliceAddr, 1, 8, 10, false) : fragment(AliceAddr, 1, 9, 10, false) : fragment(AliceAddr, 1, 10, 10, true)) 
    == packet(AliceAddr, 1, 100)  .

red getQueryCtr(incrQueryCtr(wClientAttrs, queryCtr: 10)) == 7737 .

red length(mtfl) == 0 .
red length(fragment(AliceAddr, 1, 1, 10, false) : fragment(AliceAddr, 1, 2, 10, false)) == 2 .

red length(popFront(makeFragments(packet(AliceAddr, 1, 100), 20))) == 4 .
red length(popFront(mtfl)) == 0 .

red peekFront(makeFragments(packet(AliceAddr, 1, 100), 20)) == fragment(AliceAddr, 1, 1, 20, false) .
red peekFront(mtfl) == nilFragment .

red handleNewPacket((wClientAttrs, seqCtr: 2), packet(AliceAddr, 1, 1000), 200) .
red moveFragmentUp(wClientAttrs, fragments: makeFragments(packet(AliceAddr, 1, 100), 20), currFragment: 0) .

red isWeird((appAddr: BobAddr), (to addrWNS from cAddr : query(1, nm(fragment(AliceAddr, 1, 1, 100, true)) . 'pwnd2 . 'com . root, a))) == true .
red extractS((appAddr: BobAddr, pendingFragments: mtfl), (to addrWNS from cAddr : query(1, nm(fragment(AliceAddr, 1, 1, 100, true)) . 'pwnd2 . 'com . root, a))) .