load _aux
load wmonitor
load ../../../../deps/dns_formalization/Maude/src/probabilistic-model/dns

--- DNS includes AUX + MSG + PARAMETERS .
mod IODINE_DNS is
  inc IAUX + DNS + WMONITOR .

  vars ADDR ADDR1 ADDR2 NS RESOLVER ALICE BOB : Address .
  var RCODE : Nat .
  vars ANS AUTH ADD : List{Record} .
  vars wattrs wattrs1 wattrs2 wattrsNext wattrsTrans wattrsTrans' appAttrs appAttrs1 : AttributeSet .
  vars monAttrs : AttributeSet .
  vars conf : Config .
  vars appAlice appBob wrappedNS : Actor .
  vars ID ID' : Id .      ---- Nat < Id
  vars NAME NAME' WNAME SNAME QNAME : Name .
  vars Q1 Q : Query .
  var QTYPE : RType .
  var  wdb : MapIdMsg . 
  vars msgs msgs0 : Config .   ---- MsgConfig
  vars msg msg0 msg1 msgIn msgOut msgOutExt : Msg .
  vars txComplete, maxAttemptsReached : Bool .
  var PACKETS PACKETS' : PacketList .
  var FRAGMENT_LIST : FragmentList .
  var Pkt : Packet .
  vars T T' : Float . --- timestamp
  var PTL : PacketTimestampList .
  vars QTL : QueryTimestampList .
  vars MON : Address .
  vars FRAGMENT sentFragment : Fragment .

  --------------------------------
  --- [WNameserver] --- Weird/wrapped Nameserver Rules
  --------------------------------

----  receivs DNS query with standard name
----  passthrough
----  TODO: merge into single rule below 
crl [wnameserver-receive-query-passthru]:
  < ADDR : WNameserver | wattrs,  
          conf: (appBob wrappedNS)
  >
  {T, (to ADDR from ADDR1 : query(ID, QNAME, QTYPE))}
  =>
  < ADDR : WNameserver | wattrs, 
          --- add noise to avoid nondeterminism
          conf: (appBob wrappedNS [genRandom(0.0, 0.0001), (to ADDR from ADDR1 : query(ID, QNAME, QTYPE)), 0]) 
  >
  if  not isWeird(wattrs, (to ADDR from ADDR1 : query(ID, QNAME, QTYPE))) .

----  receivs DNS query response from my nameserver
----  passthrough
rl [weird-nameserver-response-passthru]:
  < ADDR : WNameserver | wattrs,  
          conf: (appBob wrappedNS {T, (to ADDR1 from ADDR : response(ID, SNAME, ANS, AUTH, ADD, RCODE))})
  >
  =>
  < ADDR : WNameserver | wattrs, 
          conf: (appBob wrappedNS) 
  >
  --- add noise to avoid non-determinism
  [genRandom(0.0, 0.0001), (to ADDR1 from ADDR : response(ID, SNAME, ANS, AUTH, ADD, RCODE)), 0]
  .

----  receivs DNS query with weird name
----  the WNS implements its own DNS logic and responds directly
----    without relying on the wrapped NS; this may challenge
----    our modularity assumptions and modeling
----  Steps are as follows:
----  1.  add fragment to fragment list 
----  2.  respond acking the fragment
----  3.  if last fragment also defrag and send message to Bob
----  TODO: add support for NULL QTYPE which is what will be used in tests
---- TODO: ideally WNS would remove the weird name and pass the query to wrappedNS 
----      but that is not how iodine is implemented! For now, iodine directly responds.
crl [wnameserver-receive-query-weird]:
  < ADDR : WNameserver | wattrs,  
          conf: (< BOB : RcvApp | appAttrs > wrappedNS)
  >
  {T, (to ADDR from ADDR1 : query(ID, QNAME, QTYPE))}
  =>
  < ADDR : WNameserver | wattrs2,
          conf: (< BOB : RcvApp | appAttrs1 > wrappedNS) 
  >
  msgOut
  if isWeird(wattrs, (to ADDR from ADDR1 : query(ID, QNAME, QTYPE)))
  --- step 1 and step 2
  /\ {wattrs1, msgOut} := extractS(wattrs, (to ADDR from ADDR1 : query(ID, QNAME, QTYPE)))
  --- step 3
  /\ {wattrs2, appAttrs1} := updateRcvApp(wattrs1, appAttrs)
  .

  ---------------------------------------
  --- [WClient] --- Weird (Iodine) client
  ---------------------------------------
  --- Handle packet from Alice headed to Bob.
  --- If a packet is not currently being sent or numAttempts >= 2, then WClient
  --- can accept and handle the packet.
  --- (same as not sending or sending and numAttempts > 2)
  --- Handle the packet, fragment it, and send the first fragment.
  crl [iClientEmbedding]:
    < ADDR : WClient | wattrs, conf: (< ALICE : SendApp | appAttrs > {T, (to BOB from ALICE : Pkt)})
    >
    < MON : WMonitor | pktSent: PTL, querySent: QTL, monAttrs >
    =>
    < ADDR : WClient | wattrsNext, conf: (< ALICE : SendApp | appAttrs >)
    >
    < MON : WMonitor | pktSent: (PTL ; packetTimestamp(Pkt, T)), querySent: (QTL ; queryTimestamp(getQuery(msgOut), T)), monAttrs >
    [delay, msgOut, drop?]
    [delay, (to ADDR : ackTimeout(sentFragment)), 0]
    --- TODO: Replace with not hard coded.
    if (not isSending(wattrs) or getNumAttempts(wattrs) >= 2)
       /\ {wattrsNext, msgOut} := handleAndSend(ADDR, wattrs, Pkt)
       /\ sentFragment := grabCurrentFragment(wattrsNext)
---    [print "iClientEmbedding msg in"  msg]
---    [print "iClientEmbedding fragment out "  msgOut]
    .

  --- Handle a response from the resolver to WClient.
  --- Extract the ACK information and check this is for the fragment that was
  --- just sent (seqNo, fragNum match).
  --- If the packet transmission is complete (this was last fragment) then
  --- send the ALICE a msg to send one more packet.
  --- Otherwise, send the next fragment to WNameServer.
  --- TODO: Change Alice -> WClient.
  crl [iClientExtractFromServer]:
    < ADDR : WClient | (wattrs, resv: RESOLVER), conf: (< ALICE : SendApp | appAttrs >) >
    < MON : WMonitor | querySent: QTL, monAttrs >
      {T, (to ADDR from RESOLVER : response(ID, SNAME, ANS, AUTH, ADD, RCODE))}
    =>
    < ADDR : WClient | wattrsNext, conf: (< ALICE : SendApp | appAttrs > 
      (if msgOut == nullMsg then null else msgOut fi)) >
    < MON : WMonitor | querySent: if msgOutExt == nullMsg then QTL else (QTL ; queryTimestamp(getQuery(msgOutExt), T)) fi, monAttrs >
    (if msgOutExt == nullMsg then null else [delay, msgOutExt, drop?] fi)
---   Alice messages are internal and Bob / Resolver messages external.
---   Therefore, we would need to set msgOut to nil or (to ALICE : start) and 
---   require a second msg extMsgOut set to (to RESOLVER : fragment) or nil.
    if wattrsTrans := extract((wattrs, resv: RESOLVER), response(ID, SNAME, ANS, AUTH, ADD, RCODE))
      /\ txComplete := isTxComplete(wattrsTrans)
      /\ {wattrsNext, msgOutExt} :=
        if txComplete
          then {wattrsTrans, nullMsg}
          else sendFragment(wattrsTrans, ADDR)
        fi
      /\ msgOut := 
        if txComplete
        --- TODO: extract ALICE address from response also to know to send to Alice
          then [genRandom(0.0, 0.0001), (to ALICE : start), 0]
          else nullMsg
        fi
    .
  
    --- Timeout rule for WClient.
  crl [iClientTimeout]:
    < ADDR : WClient | wattrs, conf: (< ALICE : SendApp | appAttrs >) >
    < MON : WMonitor | querySent: QTL, monAttrs >
      {T, (to ADDR : ackTimeout(FRAGMENT))}
    =>
    < ADDR : WClient | wattrsNext, conf: (< ALICE : SendApp | appAttrs >
      (if msgOut == nullMsg then null else [0.0, msgOut, 0] fi)) >
    < MON : WMonitor | querySent: if msgOutExt == nullMsg then QTL else (QTL ; queryTimestamp(getQuery(msgOutExt), T)) fi, monAttrs >
    (if msgOutExt == nullMsg then null else [delay, msgOutExt, drop?] fi)
    if isSending(wattrs)
      --- If the timed out fragment does not match the current fragment, then it means we have already received the ACK and this rule should not match.
      /\ isFragmentMatch(wattrs, FRAGMENT)
      /\ maxAttemptsReached := isMaxAttemptsReached(wattrs)
      /\ {wattrsNext, msgOutExt} :=
        if maxAttemptsReached
          then {dropFragments(wattrs), nullMsg}
          else sendFragment(wattrs, ALICE)
        fi
      /\ msgOut :=
        if maxAttemptsReached
          then (to ALICE : start)
          else nullMsg
        fi
    .


    --- To start, send a start message to the send app
  rl [startWClient]:
    < ADDR : WClient | wattrs, 
      conf: (< ALICE : SendApp | toAddr: BOB, queue: (Pkt ; PACKETS), sent: PACKETS', appAttrs >
            (to ALICE : start))
    >    
    =>
    < ADDR : WClient | wattrs, 
      conf: (< ALICE : SendApp | toAddr: BOB, queue: PACKETS, sent: (Pkt ; PACKETS'), appAttrs >
            (if Pkt == nilPacket then null else [delay, (to BOB from ALICE : Pkt), 0] fi))
    >
    --- if msgOut := 
    ---     if Pkt == nilPacket
    ---       then nullMsg
    ---       else (to BOB from ALICE : Pkt)
    ---     fi
    [print "startWClient" ]
    .


endm
