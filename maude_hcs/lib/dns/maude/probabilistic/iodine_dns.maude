--- MAUDE_HCS: maude_hcs
---
--- Software Markings (UNCLASS)
--- PWNDD Software
---
--- Copyright (C) 2025 RTX BBN Technologies Inc. All Rights Reserved
---
--- Contract No: HR00112590083
--- Contractor Name: RTX BBN Technologies Inc.
--- Contractor Address: 10 Moulton Street, Cambridge, Massachusetts 02138
---
--- The U.S. Government's rights to use, modify, reproduce, release, perform,
--- display, or disclose these technical data and software are defined in the
--- Article VII: Data Rights clause of the OTA.
---
--- This document does not contain technology or technical data controlled under
--- either the U.S. International Traffic in Arms Regulations or the U.S. Export
--- Administration Regulations.
---
--- DISTRIBUTION STATEMENT A: Approved for public release; distribution is
--- unlimited.
---
--- Notice: Markings. Any reproduction of this computer software, computer
--- software documentation, or portions thereof must also reproduce the markings
--- contained herein.
---
--- MAUDE_HCS: end

load ../../../../deps/dns_formalization/Maude/dns/probabilistic-model/dns
load wmonitor
load parameters

--- DNS includes AUX + MSG + PARAMETERS .
mod IODINE_DNS is
  inc DNS + WMONITOR + IODINE-PARAMETERS .

  vars ADDR ADDR1 ADDR2 NS RESOLVER ALICE BOB : Address .
  var RCODE : Nat .
  vars ANS AUTH ADD : List{Record} .
  vars wattrs wattrs1 wattrs2 wattrsNext wattrsTrans wattrsTrans' appAttrs appAttrs1 appAttrsTrans appAttrsNext : AttributeSet .
  vars monAttrs : AttributeSet .
  vars conf : Config .
  vars appAlice appBob wrappedNS : Actor .
  vars ID ID' : Id .      ---- Nat < Id
  vars NAME NAME' WNAME SNAME SNAME' QNAME : Name .
  vars downstreamdata : RData .
  vars Q1 Q : Query .
  var QTYPE : RType .
  var  MIA MIA1 : MapIdAddr . 
  vars msgs msgs0 : Config .   ---- MsgConfig
  vars msg msg0 msg1 msgIn msgOut msgOutExt appMsgOut : Msg .
  vars queueSet txComplete maxAttemptsReached : Bool .
  var isLastFrag : Bool .
  var PACKET_LIST PACKETS PACKETS' : PacketList .
  var FRAGMENT_LIST : FragmentList .
  vars Pkt Pkt' : Packet .
  vars T T' : Float . --- timestamp
  var PTL : PacketTimestampList .
  vars QTL : QueryTimestampList .
  vars MON : Address .
  vars FRAGMENT sentFragment : Fragment .
  vars ALICEREADY WCLIENTREADY : Bool .
  vars BOBREADY WNAMESERVERREADY : Bool .
  var N : Nat .
  vars FILE_SIZE MIN_PKT_SIZE MAX_PKT_SIZE PKT_COUNTER PktSize : Nat .
  var FILE : ByteSeq .
  var sTTL : Float .
  var F : Fragment .

  op fileSize : -> Nat .
  op packetSize : -> Nat .
  op maxPacketSize : -> Nat .

  --------------------------------
  --- [WNameserver] --- Weird/wrapped Nameserver Rules
  --------------------------------

crl [iServerEmbedding]:
  < ADDR : WNameserver | wattrs >
  ---- TODO: Embed monitor behavior
  {T, (to ADDR from BOB : Pkt)}
  =>
  < ADDR : WNameserver | wattrsNext >
  --- TODO: Delays were copied from WClient, check if still applicable here
  ---[delayParamd(msgOut), msgOut, dropParamd(msgOut)]

  --- TODO: Also copied these conditions from WClient, check if this makes sense for Iodine Server
  if (not isSending(wattrs) or getNumAttempts(wattrs) >= 2)
      --- Server doesn't send, just fragment the current packet and queue it
      --- TODO: Need to be able to config Bob with a downstream fragment length different from upstream
      /\ wattrsNext := handleNewPacket(wattrs, Pkt, maxFragmentLen)
    [print "(" T ") iServerEmbedding get pkt " Pkt ", making list of fragments"]
    .

----  receivs DNS query with standard name
----  passthrough
----  TODO: merge into single rule below 
----  TODO: If Bob has data in queue, it needs to load those into WNameerver, 
crl [wnameserver-receive-query-passthru]:
  < ADDR : WNameserver | wattrs,  
          conf: (wrappedNS)
  >
  < MON : WMonitor | queryRcvd: QTL, monAttrs >
  {T, (to ADDR from ADDR1 : query(ID, QNAME, QTYPE))}
  =>
  < ADDR : WNameserver | wattrs,           
          conf: (wrappedNS (to ADDR from ADDR1 : query(ID, QNAME, QTYPE))) 
  >
  < MON : WMonitor | queryRcvd: (QTL ; queryTimestamp(query(ID, QNAME, QTYPE), T)), monAttrs >
  if  not isWeird(wattrs, (to ADDR from ADDR1 : query(ID, QNAME, QTYPE))) .

----  receivs DNS query response from my nameserver
----  passthrough
rl [weird-nameserver-response-passthru]:
  < ADDR : WNameserver | wattrs,  
          conf: (wrappedNS (to ADDR1 from ADDR : response(ID, SNAME, ANS, AUTH, ADD, RCODE)))
  >
  < MON : WMonitor | queryRcvd: QTL, monAttrs >
  =>
  < ADDR : WNameserver | wattrs, 
          conf: (wrappedNS) 
  >
  *** Figure out what to do with Response.
  < MON : WMonitor | queryRcvd: QTL, monAttrs >
  [delayParamd(to ADDR1 from ADDR : response(ID, SNAME, ANS, AUTH, ADD, RCODE)), 
  (to ADDR1 from ADDR : response(ID, SNAME, ANS, AUTH, ADD, RCODE)),
   dropParamd(to ADDR1 from ADDR : response(ID, SNAME, ANS, AUTH, ADD, RCODE))]
  .

----  receivs DNS query with weird name
----  the WNS implements its own DNS logic and responds directly
----    without relying on the wrapped NS; this may challenge
----    our modularity assumptions and modeling
----  Steps are as follows:
----  1.  add fragment to fragment list 
----  2.  respond acking the fragment
----  3.  if last fragment also defrag and send message to Bob, send 
---       ack (response) with a delay
----  TODO: add support for NULL QTYPE which is what will be used in tests
---- TODO: ideally WNS would remove the weird name and pass the query to wrappedNS 
----      but that is not how iodine is implemented! For now, iodine directly responds.
crl [wnameserver-receive-query-weird]:
  < ADDR : WNameserver | wattrs,  
          conf: (wrappedNS)
  >
  < MON : WMonitor | queryRcvd: QTL, monAttrs >
  {T, (to ADDR from ADDR1 : query(ID, QNAME, QTYPE))}
  =>
  < ADDR : WNameserver | wattrs2,
          conf: (wrappedNS) 
  >
  < MON : WMonitor | queryRcvd: (QTL ; queryTimestamp(query(ID, QNAME, QTYPE), T)), monAttrs >
  --- Message back to Alice
  (if isLastFrag then [lastFragDelay + delayParamd(msgOut), msgOut, dropParamd(msgOut)] else [delayParamd(msgOut), msgOut, dropParamd(msgOut)] fi)
  --- The message to send to Bob if packet is fully assembled
  --- TODO: Does appMsgOut need delays?
  (if appMsgOut == nullMsg then null else [0., appMsgOut, 0] fi)
  (if msgOutExt == nullMsg then null else [0.0, msgOutExt, 0] fi)
  if isWeird(wattrs, (to ADDR from ADDR1 : query(ID, QNAME, QTYPE)))
  --- step 1 and step 2
  /\ {wattrsTrans, msgOut} := extractS(wattrs, (to ADDR from ADDR1 : query(ID, QNAME, QTYPE)))
  --- step 2.5: Check if this is for the last fragment, delay send
  /\ isLastFrag := isLastFragment(QNAME)
  --- step 3
  /\ {wattrs2, appMsgOut} := updateRcvApp(wattrsTrans, (to ADDR from ADDR1 : query(ID, QNAME, QTYPE)))
  --- If transmission is complete, nudge Bob to send another packet
  /\ txComplete := isTxComplete(wattrs2)
  /\ msgOutExt := 
    if txComplete
      then (to getToAddr(query(ID, QNAME, QTYPE)) : start)
      else nullMsg
    fi
  [print "(" T ") WServer receving query " ID ]
  .

  
  ---------------------------------------
  --- [Receive App] --- Bob
  ---------------------------------------
  --- TODO: Bob should have a queue of packets to send back to Alice (from a downstream-bound file)
  --- TODO: Bob needs to know if it's currently sending a packet. If not then fragment the next packet
  --- TODO: Bob queues up files like Alice does at the start

  --- If Bob has been told to start (by the W name server), packetize its outgoing file 
  crl [receive-app-send-packet]:
    < BOB : RcvApp | appAttrs, fileDestAddr: ADDR, queuePopulated: queueSet, wnameserverReady: WNAMESERVERREADY >
    {T, (to BOB : start)}
  => 
    < BOB : RcvApp | appAttrsNext > 
    --- If going to, send packets to WNameServer
    (if msgOut == nullMsg then null else [0.0, msgOut, 0] fi)
    --- Set pacing timeout for Bob (?) TODO: Check if this is the case
    (if msgOut == nullMsg then null else [sampleUniform(pacingTimeoutDelay, pacingTimeoutDelayMax), (to BOB : pktTimeout(getPkt(msgOut))), 0] fi)
    if appAttrsTrans := (if queueSet == true
                     then (appAttrs, fileDestAddr: ADDR)
                     else (packetizeProb(appAttrs, BOB, ADDR, fileSize, packetSize, maxPacketSize), fileDestAddr: ADDR)
                     fi)
     *** The queue is populated and wnameserver is presumed ready since it sent a start
    /\ appAttrs1 := (appAttrsTrans, queuePopulated: true, wnameserverReady: true)
    /\ {appAttrsNext, msgOut} := 
        if getNumAdmittedPkts(appAttrs1) > 0
          --- If packets are ready to send to WNameServer, do it
          then sendPktBob(appAttrs1, BOB)
          --- Otherwise, wait
          else {appAttrs1, nullMsg}
        fi
        [print "(" T ") RcvApp start or nudge from wserver, send possible pkt " msgOut ", setting timeout if not null.  Has packets to send " appAttrsNext]
.

  crl [receive-app-pkt-timeout]:
    < BOB : RcvApp | appAttrs, numAdmittedPkts: N >
    {T, (to BOB : pktTimeout(Pkt'))}
  =>
    < BOB : RcvApp | appAttrsNext >
    (if msgOut == nullMsg then null else [0.0, msgOut, 0] fi)
    (if msgOut == nullMsg then null else [sampleUniform(pacingTimeoutDelay, pacingTimeoutDelayMax), (to BOB : pktTimeout(getPkt(msgOut))), 0] fi)
    if appAttrs1 := (appAttrs, numAdmittedPkts: s N)
      /\ {appAttrsNext, msgOut} :=
        if isWNameServerReady(appAttrs1)
          then sendPktBob(appAttrs1, BOB)
          else {appAttrs1, nullMsg}
        fi
        [print "(" T ") RcvApp timeout, send possible msg " msgOut ", setting timeout if not null"]
  .

  rl [receive-app-rcv-packet]:
    < ADDR : RcvApp | rcvd: PACKETS, appAttrs >
    < MON : WMonitor | pktRcvd: PTL, monAttrs >
    {T, (to ADDR from ADDR1 : Pkt)}
  => 
    < ADDR : RcvApp | appAttrsNext >
    < MON : WMonitor | pktRcvd: (PTL ; packetTimestamp(Pkt, T)), monAttrs >
    (if msgOut == nullMsg then null else [0., msgOut, 0] fi)
    if (appAttrsTrans, fileDestAddr: ADDR2, rcvd: PACKETS) := appAttrs
      /\ txComplete := isLastPacket(Pkt)
      /\ appAttrsNext := (appAttrsTrans, fileDestAddr: ADDR2, rcvd: (PACKETS ; Pkt))
      /\ msgOut :=
          (if txComplete == true
              then (to ADDR2 : getFile(Pkt))
              else nullMsg
           fi)
    [print "Bob rcv app received pkt " Pkt]
  .

  ---------------------------------------
  --- [Send App] --- Alice
  ---------------------------------------
  
  ---               Attributes   Src     Dest     File Min Max
  op packetizeProb : AttributeSet Address Address ByteSeq Nat Nat -> AttributeSet .
  ceq packetizeProb((appAttrs, queue: PACKET_LIST), ALICE, BOB, FILE, MIN_PKT_SIZE, MAX_PKT_SIZE) = appAttrs1
    if PACKETS' := $packetizeProb(mtpl, ALICE, BOB, FILE, getSize(FILE), MIN_PKT_SIZE, MAX_PKT_SIZE, 0) 
    /\ appAttrs1 := (appAttrs, queue: PACKETS')
  .

  ---             CurrentPktList Src   Dest      File FileSize Min Max Counter
  op $packetizeProb : PacketList Address Address ByteSeq Nat Nat Nat Nat -> PacketList .
  ceq $packetizeProb(PACKET_LIST, ALICE, BOB, FILE, FILE_SIZE, MIN_PKT_SIZE, MAX_PKT_SIZE, PKT_COUNTER) = PACKETS
    if PktSize := floor(MIN_PKT_SIZE + (MAX_PKT_SIZE + (- MIN_PKT_SIZE)) * (random(PKT_COUNTER) / 4294967296))
      /\ PACKETS :=
        (if FILE_SIZE > PktSize
         then
           $packetizeProb(PACKET_LIST ; packet(ALICE, BOB, FILE, PKT_COUNTER, PktSize + packetOverhead, false), ALICE, BOB, FILE, FILE_SIZE + (- PktSize), MIN_PKT_SIZE, MAX_PKT_SIZE, s PKT_COUNTER)
         else
           (PACKET_LIST ; packet(ALICE, BOB, FILE, PKT_COUNTER, FILE_SIZE + packetOverhead, true))
         fi)
    .


  *** This signals either the start or that the WClient is ready to accept new packets.
  *** Either way, Alice checks if it is ready (now is passed the previous app timeout)
  *** and sends a packet if so.  Otherwise, it marks WClient as ready and waits for its
  *** own timeout.
  crl [send-app-send-packet]:
    < ALICE : SendApp | appAttrs, fileDestAddr: ADDR, queuePopulated: queueSet, wclientReady: WCLIENTREADY >
    {T, (to ALICE : start)}
  =>
    < ALICE : SendApp | appAttrsNext >
    (if msgOut == nullMsg then null else [0.0, msgOut, 0] fi)
    (if msgOut == nullMsg then null else [sampleUniform(pacingTimeoutDelay, pacingTimeoutDelayMax), (to ALICE : pktTimeout(getPkt(msgOut))), 0] fi)
    *** Start means that the client is ready.
    *** Check if the packet queue needs to be filled.
    *** If so, packetize the file.
    if appAttrsTrans := (if queueSet == true
                     then (appAttrs, fileDestAddr: ADDR)
                     else (packetizeProb(appAttrs, ALICE, ADDR, file(fileSize), packetSize, maxPacketSize), fileDestAddr: ADDR)
                     fi)
    *** The queue is populated, and the wclient is ready.
    /\ appAttrs1 := (appAttrsTrans, queuePopulated: true, wclientReady: true)
    /\ {appAttrsNext, msgOut} :=
        if getNumAdmittedPkts(appAttrs1) > 0
          *** If Alice has already admitted packets, send the next one.
          then sendPkt(appAttrs1, ALICE)
          *** Otherwise, it is not time yet.  Leave wclient marked as ready and done nothing else.
          else {appAttrs1, nullMsg}
        fi
        [print "(" T ") SendApp start or nudge from wclient, send possible pkt " msgOut ", setting timeout if not null.  Has packets to send " appAttrsNext]
  .

  rl [send-app-rcv-packet]:
    < ADDR : SendApp | rcvd: PACKETS, appAttrs >
    < MON : WMonitor | pktRcvd: PTL, monAttrs >
    {T, (to ADDR from ADDR1 : Pkt)}
  => 
    < ADDR : SendApp | rcvd: (Pkt ; PACKETS), appAttrs >
    < MON : WMonitor | pktRcvd: (PTL ; packetTimestamp(Pkt, T)), monAttrs >
  .

  ---- ************
  ---- Timeout rule for Alice (receive timeout and send next packet)
  ---- ************
  crl [send-app-pkt-timeout]:
    < ALICE : SendApp | appAttrs, numAdmittedPkts: N >
    {T, (to ALICE : pktTimeout(Pkt'))}
  =>
    < ALICE : SendApp | appAttrsNext >
    (if msgOut == nullMsg then null else [0.0, msgOut, 0] fi)
    (if msgOut == nullMsg then null else [sampleUniform(pacingTimeoutDelay, pacingTimeoutDelayMax), (to ALICE : pktTimeout(getPkt(msgOut))), 0] fi)
    *** Timeout means it is OK to send a packet now.
    if appAttrs1 := (appAttrs, numAdmittedPkts: s N)
      /\ {appAttrsNext, msgOut} := 
        if isWClientReady(appAttrs1)
          *** Conveniently, the client is ready, send now.
          then sendPkt(appAttrs1, ALICE)
          *** Client is busy, add pkt to OK to send, do nothing else.
          else {appAttrs1, nullMsg}
        fi
        [print "(" T ") SendApp timeout, send possible msg " msgOut ", setting timeout if not null"]
  .

  --- ***
  --- Handle receiving a file to send over Iodine.
  --- ***
  rl [send-app-handle-file]:
    < ALICE : SendApp | appAttrs, fileDestAddr: ADDR, queuePopulated: false >
    {T, (to ALICE from ADDR1 : FILE)}
  =>
    < ALICE : SendApp | packetizeProb((appAttrs, fileDestAddr: ADDR, queuePopulated: true),
                                      ALICE, ADDR, FILE, packetSize, maxPacketSize) >
    [0., (to ALICE : start), 0]
    [print "(" T ") SendApp handling file " FILE ]
    .


  ---------------------------------------
  --- [WClient] --- Weird (Iodine) client
  ---------------------------------------
  --- Handle packet from Alice headed to Bob.
  --- If a packet is not currently being sent or numAttempts >= 2, then WClient
  --- can accept and handle the packet.
  --- (same as not sending or sending and numAttempts > 2)
  --- Handle the packet, fragment it, and send the first fragment.
  crl [iClientEmbedding]:
    < ADDR : WClient | wattrs >
    < MON : WMonitor | querySent: QTL, pktSent: PTL, monAttrs >
    {T, (to ADDR from ALICE : Pkt)}
    =>
    < ADDR : WClient | wattrsNext >
    < MON : WMonitor | querySent: (QTL ; queryTimestamp(getQuery(msgOut), T)), pktSent: (PTL ; packetTimestamp(Pkt, T)), monAttrs >
    [delayParamd(msgOut), msgOut, dropParamd(msgOut)]
    [ackTimeoutDelay + genRandom(0.0, 0.0001), (to ADDR : ackTimeout(sentFragment)), 0]
    --- TODO: Modify rule to drop incoming message if >= 2, continue on with current.
    if (not isSending(wattrs) or getNumAttempts(wattrs) >= 2)
       /\ {wattrsNext, msgOut} := handleAndSend(wattrs, ADDR, Pkt)
       /\ sentFragment := grabCurrentFragment(wattrsNext)
    [print "(" T ") iClientEmbedding get pkt " Pkt ", sending fragment out "  msgOut ", setting ackTimeout"]
    .

  --- Handle a response from the resolver to WClient.
  --- Extract the ACK information and check this is for the fragment that was
  --- just sent (seqNo, fragNum match).
  --- If the packet transmission is incomplete 
  --- send the next fragment to WNameServer.
  crl [iClientExtractFromServer]:
    < ADDR : WClient | resv: RESOLVER, pendingFragments: FRAGMENT_LIST, wattrs >
    < MON : WMonitor | querySent: QTL, monAttrs >
      {T, (to ADDR from RESOLVER : response(ID, SNAME, < SNAME', QTYPE, sTTL, downstreamdata >, AUTH, ADD, RCODE))}
    =>
    < ADDR : WClient | wattrs2 >       
    < MON : WMonitor | querySent: if msgOutExt == nullMsg then QTL else (QTL ; queryTimestamp(getQuery(msgOutExt), T)) fi, monAttrs >
    (if msgOutExt == nullMsg 
     then [0.0, (to getFromAddr(response(ID, SNAME, < SNAME', QTYPE, sTTL, downstreamdata >, AUTH, ADD, RCODE)) : start), 0]
     else [delayParamd(msgOutExt), msgOutExt, dropParamd(msgOutExt)] fi)
    (if msgOutExt == nullMsg then 
     null 
     else [ackTimeoutDelay + genRandom(0.0, 0.0001), (to ADDR : ackTimeout(sentFragment)), 0] fi)
    (if appMsgOut == nullMsg then null else [0., appMsgOut, 0] fi)
    if wattrsTrans := extract((resv: RESOLVER, pendingFragments: FRAGMENT_LIST, wattrs), response(ID, SNAME, < SNAME', QTYPE, sTTL, downstreamdata >, AUTH, ADD, RCODE))
      /\ txComplete := isTxComplete(wattrsTrans)
      /\ {wattrsNext, msgOutExt} :=
        if txComplete
          --- TODO: Investigate how iodine.c client handles ACKing server data when it's done sending upstream, likely a ping? (client.c:1070)
          then {wattrsTrans, nullMsg}
          else sendFragment(wattrsTrans, ADDR)
        fi
      /\ sentFragment := grabCurrentFragment(wattrsNext)
      /\ {wattrs2, appMsgOut} := updateRcvAppAlice(wattrsNext, (to ADDR from RESOLVER : response(ID, SNAME, < SNAME', QTYPE, sTTL, downstreamdata >, AUTH, ADD, RCODE)))
      --- TODO remove printout when done debugging
      [print "(" T ") WClient got response " ID ": sending possible fragment " msgOutExt " got something weird " downstreamdata]
    .

  --- Handle a response from the resolver to WClient that is for a past Fragment.
  --- This handles the case when a response does not match the current fragment.
  --- Presumably, WClient has already moved forward in its fragments list, and 
  --- and receives an old response.  It should drop it and do nothing.
  --- TODO: This would be better handle with an owise, but not sure how to do that.
  crl [wClientExtractOldResponseFromServer-ignore]:
    < ADDR : WClient | resv: RESOLVER, wattrs >
      {T, (to ADDR from RESOLVER : response(ID, SNAME, < SNAME', QTYPE, sTTL, downstreamdata >, AUTH, ADD, RCODE))}
    =>
    < ADDR : WClient | (resv: RESOLVER, wattrs) > 
    if nm(FRAGMENT) := downstreamdata
      /\ not isFragmentMatch((wattrs, resv: RESOLVER), FRAGMENT)
      [print "(" T ") WClient got outdated response to query " ID ", dropping it"]
    .
  
    --- Timeout rule for WClient.
  crl [iClientTimeout]:
    < ADDR : WClient | wattrs >
    < MON : WMonitor | querySent: QTL, monAttrs >
    {T, (to ADDR : ackTimeout(FRAGMENT))}
    =>
    < ADDR : WClient | wattrsNext >    
    < MON : WMonitor | querySent: if msgOutExt == nullMsg then QTL else (QTL ; queryTimestamp(getQuery(msgOutExt), T)) fi, monAttrs >
    --- Either ask for the next packet when the current one is being dropped, or send fragment out.
    (if msgOutExt == nullMsg 
     then [0.0, (to getFromAddr(FRAGMENT) : start), 0] 
     else [delayParamd(msgOutExt), msgOutExt, dropParamd(msgOutExt)] fi)
    (if msgOutExt == nullMsg then null else [ackTimeoutDelay + genRandom(0.0, 0.00001), (to ADDR : ackTimeout(sentFragment)), 0] fi)
    if isSending(wattrs)
      --- If the timed out fragment does not match the current fragment, 
      ---  then we have already received the ACK and this rule should not match.
      /\ isFragmentMatch(wattrs, FRAGMENT)
      /\ maxAttemptsReached := isMaxAttemptsReached(wattrs)
      /\ {wattrsNext, msgOutExt} :=
        if maxAttemptsReached
          then {dropFragments(wattrs), nullMsg}
          else sendFragment(wattrs, ADDR)
        fi
      /\ sentFragment := grabCurrentFragment(wattrsNext)
      [print "(" T ") WClient ACK Timeout: sending possible fragment " msgOutExt " or requesting new packet" ]
    .

  --- Timeout rule for catching WClient timeout when it has become moot.
  crl [iClientTimeout-ignore]:
    < ADDR : WClient | wattrs >
    {T, (to ADDR : ackTimeout(FRAGMENT))}
    =>
    < ADDR : WClient | wattrs >
    if not (isSending(wattrs) and isFragmentMatch(wattrs, FRAGMENT))
    [print "(" T ") WClient ignoring timeout" ]
  .

endm
