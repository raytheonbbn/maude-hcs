--- MAUDE_HCS: maude_hcs
---
--- Software Markings (UNCLASS)
--- Maude-HCS Software
---
--- Copyright (C) 2025 RTX BBN Technologies Inc. All Rights Reserved
---
--- The computer software and computer software documentation are licensed
--- under the Apache License, Version 2.0 (the "License"); you may not use
--- this file except in compliance with the License. A copy of the License
--- is provided in the LICENSE file, but you may obtain a copy of the
--- License at:  https://www.apache.org/licenses/LICENSE-2.0
---
--- The computer software and computer software documentation are based
--- upon work supported by the Defense Advanced Research Projects Agency (DARPA)
--- under Agreement No. HR00l 12590083.
---
--- This document does not contain technology or technical data controlled under
--- either the U.S. International Traffic in Arms Regulations or the U.S. Export
--- Administration Regulations.
---
--- DISTRIBUTION STATEMENT A: Approved for public release; distribution is
--- unlimited.
---
--- Notice: Markings. Any reproduction of this computer software, computer
--- software documentation, or portions thereof must also reproduce the markings
--- contained herein. Refer to the provided NOTICE file.
---
--- MAUDE_HCS: end

load ../../../common/maude/user-action-actor.maude
load ../probabilistic/dns-mamodel.maude

mod TEST-UAA is
  inc USER-ACTION-ACTOR .
  inc DNS-MAMODEL .

ops umA aA : -> Address .
op umAct : -> Actor .
eq umAct = mkUMactor(umA,dns-ma,aA) .

op umAttrs : -> AttributeSet .
eq umAttrs = getAttrs(umAct) .

op xmsg0 : -> Config .
eq xmsg0 = getW4A(umAttrs) .

op xmm : -> Map{String,Map{String,Float}} .
eq xmm = getMarkovA(umAttrs) .

op xacts : -> Map{String,JV} .
eq xacts = getActionsA(umAttrs) .

**** sid = "single"
**** sid1 : "wait_single"

op umAct1 : -> Actor .
eq umAct1 =
< umA : UM | markov: ("batch" |-> "wait_batch" |-> 1.0, "single" |-> "wait_single" |-> 1.0, "wait_batch" |-> ("batch" |-> 5.0e-1, "single" |-> 5.0e-1), "wait_single" |-> ( "batch" |-> 5.0e-1, "single" |-> 5.0e-1)), actions: ("batch" |-> jo(("num_to_resolve" |-> jo(("max" |-> jn(10), "min" |-> jn(2), "random" |-> js("uniform"))), "type" |-> js("resolve_a_batch"))), "single" |-> jo("type" |-> js("resolve_a")),
"wait_single" |-> jo(("sleep" |-> jo(("mean" |-> jf(2.0e+1), "random" |-> js("gaussian"), "std" |-> jf(2.0))), "type" |-> js("wait"))), 
"wait_batch" |-> jo(("sleep" |-> jo(("mean" |-> jf(2.0e+1), "random" |-> js("gaussian"), "std" |-> jf(2.0))), "type" |-> js( "wait")))), 
curState: "wait_single", nsteps: 99, actAddress: aA, 
w4: (to aA from umA : actionQ("type" |-> js("resolve_a")))
 >
.   
endm

red umAct .
rew {0.0, (to umA from umA : actionR(""))} umAct  rCtr(0) .
**** [5.9284461638890209e-6, to aA from umA : actionQ("type" |-> js("resolve_a")), 0]
rew {1.0, (to umA from aA : actionR("ok"))} umAct1  rCtr(2) .
**** [2.0649674586612935e+1, to umA from umA : actionR("ok"), 0]

----- TEST CASES ----

red dns-markov == ("batch" |-> "wait_batch" |-> 1.0,
    "single" |-> "wait_single" |-> 1.0, "wait_batch" |-> ("batch" |->
    5.0e-1, "single" |-> 5.0e-1), "wait_single" |-> ("batch" |-> 5.0e-1,
    "single" |-> 5.0e-1)) .

red getActions(dns-ma) == dns-actions .
red getParams(dns-ma) == dns-params .

red getStart(dns-ma) == "single" .
red getMaxSteps(dns-ma) == 100 .

red isWaitType(getJOmap(dns-actions["single"])) == false .
red isWaitType(getJOmap(dns-actions["wait_single"])) == true .

red realizeParams(dns-actions["batch"], 0) == 
                    {"num_to_resolve" |-> jn(6), 
                    "type" |-> js("resolve_a_batch")
                    , 1} .

