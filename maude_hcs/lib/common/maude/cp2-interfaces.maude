--- MAUDE_HCS: maude_hcs
---
--- Software Markings (UNCLASS)
--- Maude-HCS Software
---
--- Copyright (C) 2025 RTX BBN Technologies Inc. All Rights Reserved
---
--- The computer software and computer software documentation are licensed
--- under the Apache License, Version 2.0 (the "License"); you may not use
--- this file except in compliance with the License. A copy of the License
--- is provided in the LICENSE file, but you may obtain a copy of the
--- License at:  https://www.apache.org/licenses/LICENSE-2.0
---
--- The computer software and computer software documentation are based
--- upon work supported by the Defense Advanced Research Projects Agency (DARPA)
--- under Agreement No. HR00l 12590083.
---
--- This document does not contain technology or technical data controlled under
--- either the U.S. International Traffic in Arms Regulations or the U.S. Export
--- Administration Regulations.
---
--- DISTRIBUTION STATEMENT A: Approved for public release; distribution is
--- unlimited.
---
--- Notice: Markings. Any reproduction of this computer software, computer
--- software documentation, or portions thereof must also reproduce the markings
--- contained herein. Refer to the provided NOTICE file.
---
--- MAUDE_HCS: end

set show advisories off .

sload byteseq.maude
sload json.maude

sload ../../../deps/dns_formalization/Maude/common/actor.maude
sload ../../../deps/dns_formalization/Maude/common/apmaude.maude
sload ../../../deps/dns_formalization/Maude/dns/probabilistic-model/parameters.maude

sload ../../mastodon/maude/common/tag.maude
sload ../../mastodon/maude/common/media_file.maude
***** load ../../mastodon/maude/common/_aux.maude

***(
There are two flavors of interface: 
   service
      single actor identified by address
      receives 'requests', sends `responses'
      The interface is given by content constructors
        for these messages
   channel  -- a pair of actors, 
     uni directional
        -- input actor  (known to sender)
        -- output actor (knows receiver)
        one content constructor 
        -- received by input actor sent by output actor
    bi directional -- two endpoint actors
       endpoint1  -- content constructors 1->2
       endpoint2  -- content constructors 2->1
         each endpoint knows its owner/customer

Note that the Mastodon Client provides a service 
as does the Mastodon Server, the DNS Resolver ...

A Raceboat client-server pair is a channel
An Iodine client-server pair is a channel

A service or channel may use other services
(or channels), but the user of the interface 
doesn't (can not) need to know what these are.

)

mod CP2-COMMON is
  inc SCHEDULER .
  inc ACTOR-MODEL .
  inc PARAMETERS .

vars config msgs msgs0 : Config .
vars msg : Msg .
vars addr : Address .
vars attrs  attrs0 : AttributeSet .
vars atype : ActorType .
 
op defaultDelay : -> Float .
 
op delayMsgs : Config Config -> Config .
eq delayMsgs(null,config) = config .
eq delayMsgs(msg msgs0, config) =
   delayMsgs(msgs0, config [delayParamd(msg),msg,0] )
  .

op rCtr : Nat -> Actor [ctor] .

op getAttrs : Actor -> AttributeSet .
eq getAttrs(< addr : atype | attrs >) = attrs .
eq getAttrs(a:Actor) = noneAS [owise] .


op setAttrs : Actor AttributeSet -> Actor .
op setAttrs : AttributeSet AttributeSet -> AttributeSet .
eq setAttrs(< addr : atype | attrs > , attrs0 )
   = < addr : atype |  setAttrs(attrs, attrs0) >  
  .

eq setAttrs(attrs,attrs0)  = attrs, attrs0 [owise] .

     

endm

---- UM TGEN 
mod TGEN-INTERFACE is
 inc ACTOR-MODEL .
 inc JSON .
 inc MAP{String,JV} .
 
 op actionQ : Map{String,JV} -> Content .
 op actionR : String -> Content .
endm 


--- raceboat channel
mod RB-INTERFACE is
 inc ACTOR-MODEL .
 inc BYTESEQ .

--- sent by Alice, received by Bob
op pkg : ByteSeq -> Content .
op pkg : ByteSeq ByteSeq -> Content .

endm

***(
part of CP1 

mod IODINE-UNI-INTERFACE is
 inc ACTOR-MODEL .
 inc IODINE-AUX .
 
subsort Packet < Content .
endm

mod DNS-RESOLVER-INTERFACE is
 inc ACTOR-MODEL .
 inc ...
  
subsort Query < Content .  
subsort Response < Content .  
endm
) 

mod IODINE-BI-INTERFACE is
  inc ACTOR-MODEL .
  inc BYTESEQ .

--- alice -> bob
****    fId   tag     key    hash
op c2 : Nat ByteSeq ByteSeq ByteSeq
     -> Content [ctor] .

***(
could be represented by 6 numbers
  (fileId, wHashTagIx, filesize, keyId, keySize, hashSize)
reconstruct(fileId,wHashTagIx, filesize,
            keyId, keySize, hashSize)
 =  wHashTag(wHashTagIx) ; key(keyId,keySize) ;
    hash(file(fileId,filesize),hashSize)
)

--- alice -> bob
  op hash-key : ByteSeq ByteSeq -> Content [ctor] .
---- bob -> alice
  op status : String -> Content [ctor] .
endm  

--- mastodon client interface
mod MC-INTERFACE is
 inc ACTOR-MODEL .
 inc BYTESEQ .
 inc TAGS .
 inc MEDIA_FILES .

***** RB perspective
  op fetchQ : ByteSeq -> Content .
  op fetchR : ByteSeqL -> Content .
  op fetchR : ByteSeqL ByteSeq -> Content .

  op tootQ : ByteSeq ByteSeq -> Content .
  op tootR : String -> Content .

*****  MC perspective  
***** from _mas_aux
  op GetMediaHashtag : Tag -> Content .
  op GetMediaHashtag : Tag Nat -> Content .
  op PostStatus : String MediaFileList -> Content .
  op ResponseMediaList : Tag MediaFileList 
                           -> Content [ctor] .
  op mkRequestResponse : String -> Content [ctor] .

vars j : Nat .
vars str hstr : String .
vars ix : FindResult .
vars byteseq hashtag image : ByteSeq .
vars byteseql imagel : ByteSeqL .
vars tag : Tag .
vars mediaFile : MediaFile .
vars mediaFileList mediafileL : MediaFileList .
  
**** op GetMediaHashtag -> Tag -> Content .

op hashtag2string : ByteSeq -> String .
eq hashtag2string(hashTag(hashtag:String)) = hashtag:String .
eq hashtag2string(byteseq) = "" [owise] .

op hashtag2tag : ByteSeq -> Tag .
eq hashtag2tag(hashtag) = 
        makeTag(hashtag2string(hashtag)) .

op hashtag2text : ByteSeq -> String .
eq hashtag2text(hashtag) 
      = "hashtag is #" + hashtag2string(hashtag) .

op mkHashTag : String Nat -> ByteSeq .
eq mkHashTag(hstr,j) = hashTag(hstr) .
---   (if hstr == "wHashTag"
---    then wHashTag(j)
---    else bHashTag(j)
---    fi)
---.    

op tag2hashtag : Tag -> ByteSeq .
op tagstr2hashtag : String -> ByteSeq .
---eq tag2hashtag(makeTag(str)) = tagstr2hashtag(str) .
eq tag2hashtag(makeTag(str)) = hashTag(str) .
---ceq tagstr2hashtag(str) = mkHashTag(hstr,j)
---if ix := find(str,"-",0)
---/\ hstr := (if ix :: Nat
---            then substr(str,0,ix)
---            else ""
---            fi)
---/\ j :=  (if ix :: Nat
---          then rat(substr(str,s ix, length(str) ),10 )
---          else 0
---          fi)           
---.
---eq tagstr2hashtag(str) = bHashTag(0) [owise] .
          
op translateFetchQ : Content -> [Content] .
eq translateFetchQ(fetchQ(hashtag)) 
   =  GetMediaHashtag(hashtag2tag(hashtag)) .

**** from media_file.maude
**** op ResponseMediaList : Tag MediaFileList -> Content [ctor] .

 op getImageListFromMCResponse : Content -> ByteSeqL .
 eq getImageListFromMCResponse(
         ResponseMediaList(tag,mediaFileList) )
   = mediaFileL2bytesL(mediaFileList) .
  
op mediaFileL2bytesL : MediaFileList -> ByteSeqL .
op mediaFileL2bytesLX : MediaFileList ByteSeqL -> ByteSeqL .
eq mediaFileL2bytesL(mediafileL) =
      mediaFileL2bytesLX(mediafileL,nilBS) .

eq mediaFileL2bytesLX(mediaFile :: mediafileL, byteseql)
 = mediaFileL2bytesLX( mediafileL,
                     byteseql :: getPayload(mediaFile)) .
eq mediaFileL2bytesLX(emptyMediaFileList, byteseql)
    = byteseql .
 
 op getHashTagFromMCResponse : Content -> ByteSeq .
 eq getHashTagFromMCResponse(
         ResponseMediaList(tag,mediaFileList) )
   = tag2hashtag(tag) .
 
op translate2FetchR : Content -> Content .
eq translate2FetchR(ResponseMediaList(tag,mediaFileList))
    = fetchR(mediaFileL2bytesL(mediaFileList),
            tag2hashtag(tag) )
.            
                      
op image2mediafile : ByteSeq -> MediaFile .
ceq image2mediafile(image) = 
  --- Leave makeMediaFilename declared but undefined, so that filenames not
  --- conflict: if we define makeMediaFilename to be based on e.g., an image
  --- index, two MediaFiles may end up with the same name, which confuses the
  --- Mastodon server.
   makeMediaFile(makeMediaFilename(image),
                 nbytes(image),
                   image)
   if j := imageId(image)
.

op translateTootQ : Content -> Content .
eq translateTootQ(tootQ(hashtag,image))  =
       PostStatus(hashtag2text(hashtag), 
                  image2mediafile(image)) .
                  
endm


mod ED-INTERFACE is
 inc ACTOR-MODEL .
 inc BYTESEQ .

  op encQ : ByteSeq -> Content .
  op encR : ByteSeq -> Content .

  op capQ : Nat -> Content .
  op capR : Nat -> Content .

  op decQ : ByteSeqL -> Content .
  op decR : ByteSeqL -> Content .
  
endm

eof

application/src/common.py

def parse_ctrl_message(msg):
    """
    msg: bytes
    return all fields in a dict
    """
    hashtag_len = len(msg) - 67
    data = struct.unpack(f">BH32s32s{hashtag_len}s", msg)
    return {
        "message_type": data[0],
        "file_id": data[1],
        "md5": data[2],
        "key": data[3],
        "hashtag": data[4],
    }

def build_ack_message(file_id, status_code):
    """
    Status codes:
    1: checksums match
    2: checksums dont match
    3. timeout?
    """
    return struct.pack(">BH", status_code, file_id)


***(

TODO
DNSTGen, MastodonTGen interfaces
Action < Content 
  PostA(type)
  FetchA
  QueryA 
T&E examples show that DNS server address is
a parameter as well as batch size  
)
