
***(

Different actors (developed by different team
members) need to agree on some data structures. One
example is data structures for files, fragments,
text, images, keys ... . I propose thinking of all
of these as byte sequences, sort ByteSeq.

We need to compute the size of a byte sequence 
from basic byte sequence contructions and the
results of transformation  by operations
such as encryption, hashing, encoding in an image ...

We could define subsorts File, Image .... but I
don't think it helps. If needed we can define
isFile, isImage, isText, isKey... rather than having
separate subsorts.

The module BYTESEQ defines constructors for the
various kinds of byte sequence and equations to
extract information. I think the only thing Mastadon
should care about is that it gets requests
with parameters of sort ByteSeq  and the size
computed by the function nbytes.

In addition to the file/image related data structures
we need to agree on content exchanged in messages
i.e. content received and sent by each actor type.
TBD

)

fmod BYTESEQ is    
  inc CONVERSION .
  
vars id i j k l l0 n n0  n1 last last0 r d ix ix0 cap : Nat .
*** vars tot oh fragMx accum : Nat .
vars bytes bytes0 : ByteSeq .
vars file efrag efile image key ef ef0 : ByteSeq .
vars efl efl1 efl0 : ByteSeqL .

sorts ByteSeq ByteSeqL .
subsort ByteSeq < ByteSeqL .
op nilBS : ->   ByteSeqL [ctor] .
op _;_ : ByteSeqL ByteSeqL -> ByteSeqL [ctor assoc id: nilBS] .

op noBytes : -> ByteSeq [ctor] .

------- generating distinct benign and weird hash tags
op wHashTag : Nat -> ByteSeq [ctor] .
op bHashTag : Nat -> ByteSeq [ctor] .

*********** text
**** index/id  size
op text : Nat Nat -> ByteSeq [ctor] .

***** files 
****      id  size
op file : Nat Nat -> ByteSeq [ctor] .

**** encrypted file 
   --- not strictly needed, but maybe compacts notation
****       id  fsize, key index, key len
op efile : Nat Nat Nat Nat -> ByteSeq [ctor] .

****  keys
****     ix  len
op key : Nat Nat -> ByteSeq [ctor] . --- key generator

**** encryption
op encrypt : ByteSeq ByteSeq -> ByteSeq .
eq encrypt(file(id,n),key(j,k)) = efile(id,n,j,k) .

op decrypt : ByteSeq ByteSeq -> ByteSeq .
eq decrypt(efile(id,n,j,k),key(j,k)) = file(id,n) .
eq decrypt(encrypt(bytes,key(j,k)), key(j,k)) = 
       bytes [owise] .
 
****       hash len 
op hash : ByteSeq Nat -> ByteSeq .

**** computing len/size of ByteSeq terms
op nbytes : ByteSeq -> Nat .

eq nbytes(noBytes) = 0 .
eq nbytes(key(j,k)) = k .
eq nbytes(file(id,n)) = n .
eq nbytes(text(id,n)) = n .

*** we need to know the encryption algorithm overhead
*** give input size and key length
op encOH : Nat Nat -> Nat .
eq nbytes(efile(id,n,j,k))  = n + encOH(n,k) .
eq nbytes(hash(file(id,n),k)) = k .

****  efile fragment constructor
***(  
 efrag(efile,last, ix ,l)
  ix in [0,last] the fragment index 
  l the fragment length (number of efile bytes)
  last is the index of the last fragment
    so last+1 is the number of fragments
)    
op efrag : ByteSeq Nat Nat Nat -> ByteSeq [ctor] .
--- overhead of file metadata in efrag --- TBD
op efragOH : ByteSeq -> Nat .  
eq nbytes(efrag(bytes,last,ix,l)) = l + efragOH(bytes) .

*********  image sorts functions ********************
**** image(j,k,n)  image j with cap k size n

op image : Nat Nat Nat -> ByteSeq .

*******     image  efrag  rand density
op encode : ByteSeq ByteSeq Nat Nat -> ByteSeq .
---- decoder will need to know what the params should be
---- decoder can't see the constructor params
op decode : ByteSeq Nat Nat -> ByteSeq .
eq decode(encode(image,efrag, r,d),r,d) = efrag .

eq nbytes(image(j,k,n)) = n .
eq nbytes(encode(image(j,k,n),
         efrag(efile(id,n1,j,k),n0,ix,l),r,d))
     =  n + bloat(k,n,l) .

**** bloat(k,n,l) is the increase in size of an image of
    ----size n with capacity k when l bytes are embedded.

**** TBDefined
op bloat : Nat Nat Nat -> Nat .
 

endfm

eof
